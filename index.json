[
{
	"uri": "https://swift.jokerhub.cn/swift/",
	"title": "Swift",
	"tags": [],
	"description": "",
	"content": "Swift编程语言 Swift 是编写软件的绝佳方式，无论是用于手机、台式机、服务器还是任何其他运行代码的软件。\n它是一种安全、快速和交互式的编程语言，结合了现代语言思维的精华、Apple工程文化以及来自开源社区的各种贡献。\nSwift 编译器针​​对性能进行了优化，Swift 语言针对开发进行了优化，两者都没有妥协。\nSwift 对新手程序员很友好。它是一种工业级编程语言，与脚本语言一样富有表现力和乐趣。在 playground 中编写 Swift 代码可让您试验代码并立即查看结果。\n代码经过编译和优化，充分利用现代硬件。强大的类型推断和模式匹配与现代、轻量级的语法相结合，使复杂的想法能够以清晰简洁的方式表达。因此，代码不仅更易于编写，而且更易于阅读和维护。\n简单入门Swift基础语法，可以学习 👉 A Swift Tour，强烈建议硬刚英文，因为技术性英文只需要坚持一段时间，就可以适应，并不很难，尤其现在又有很多翻译工具可以辅助。\nSwift官方已经整理了相当全面的文档资料，并且很容易进行访问和学习，更新也很及时，下面直接罗列一下官方文档链接：\nIntroduction - Guide - Reference - Revision History\n因为官方文档是英文的，有英文阅读能力的建议直接学习官方文档，不太擅长英文的也建议硬刚，对于一些官方文档中需要深入学习的部分，再单独写文章进行挖掘。\nMacOS Windows 按下Command键同时再去点击链接，可以在新的浏览器窗口打开页面\n按下Ctrl键同时再去点击链接，可以在新的浏览器窗口打开页面\n当然也有对应的 Swift语言中文翻译，由于相对于英文版时效性比较差，并不能保持和Swift当前版本一样的更新进度，优先推荐学习官方英文版。\n如果你已经学习完基础的Swift语法，接触过一些Apple平台的项目，同时对视频学习也比较接受，也可以直接学习 WWDC 历年的视频集合，不过由于视频太多，全部学习不太现实，可以找自己比较侧重和关心的部分重点学习，这里苹果也提供了一个针对开发者的App，可以直接在应用内访问相关的学习资源：Developer\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftpm/spm_in_cli/",
	"title": "命令行下的SPM",
	"tags": [],
	"description": "",
	"content": "查看命令行帮助信息 Swift工具链安装完成后，可以在控制台下使用下面命令查看Swift Package Manager的使用方法:\nswift package --help 可以看到下面的帮助信息：\n$ swift package --help OVERVIEW: Perform operations on Swift packages SEE ALSO: swift build, swift run, swift test USAGE: swift package \u0026lt;options\u0026gt; \u0026lt;subcommand\u0026gt; OPTIONS: --package-path \u0026lt;package-path\u0026gt; Specify the package path to operate on (default current directory). This changes the working directory before any other operation --cache-path \u0026lt;cache-path\u0026gt; Specify the shared cache directory path --config-path \u0026lt;config-path\u0026gt; Specify the shared configuration directory path --security-path \u0026lt;security-path\u0026gt; Specify the shared security directory path --scratch-path \u0026lt;scratch-path\u0026gt; Specify a custom scratch directory path (default .build) --enable-dependency-cache/--disable-dependency-cache Use a shared cache when fetching dependencies (default: true) --enable-build-manifest-caching/--disable-build-manifest-caching (default: true) --manifest-cache \u0026lt;manifest-cache\u0026gt; Caching mode of Package.swift manifests (shared: shared cache, local: package\u0026#39;s build directory, none: disabled (default: shared) -v, --verbose Increase verbosity to include informational output --very-verbose, --vv Increase verbosity to include debug output --disable-sandbox Disable using the sandbox when executing subprocesses --enable-netrc/--disable-netrc Load credentials from a .netrc file (default: true) --netrc-file \u0026lt;netrc-file\u0026gt; Specify the .netrc file path. --enable-keychain/--disable-keychain Search credentials in macOS keychain (default: true) --resolver-fingerprint-checking \u0026lt;resolver-fingerprint-checking\u0026gt; (default: strict) --enable-prefetching/--disable-prefetching (default: true) --force-resolved-versions, --disable-automatic-resolution, --only-use-versions-from-resolved-file Only use versions from the Package.resolved file and fail resolution if it is out-of-date --skip-update Skip updating dependencies from their remote during a resolution --disable-scm-to-registry-transformation disable source control to registry transformation (default: disabled) --use-registry-identity-for-scm look up source control dependencies in the registry and use their registry identity when possible to help deduplicate across the two origins (default: disabled) --replace-scm-with-registry look up source control dependencies in the registry and use the registry to retrieve them instead of source control when possible (default: disabled) -c, --configuration \u0026lt;configuration\u0026gt; Build with configuration (default: debug) -Xcc \u0026lt;Xcc\u0026gt; Pass flag through to all C compiler invocations -Xswiftc \u0026lt;Xswiftc\u0026gt; Pass flag through to all Swift compiler invocations -Xlinker \u0026lt;Xlinker\u0026gt; Pass flag through to all linker invocations -Xcxx \u0026lt;Xcxx\u0026gt; Pass flag through to all C++ compiler invocations --triple \u0026lt;triple\u0026gt; --sdk \u0026lt;sdk\u0026gt; --toolchain \u0026lt;toolchain\u0026gt; --sanitize \u0026lt;sanitize\u0026gt; Turn on runtime checks for erroneous behavior, possible values: address, thread, undefined, scudo --auto-index-store/--enable-index-store/--disable-index-store Enable or disable indexing-while-building feature (default: autoIndexStore) --enable-parseable-module-interfaces -j, --jobs \u0026lt;jobs\u0026gt; The number of jobs to spawn in parallel during the build process --emit-swift-module-separately --use-integrated-swift-driver --experimental-explicit-module-build --print-manifest-job-graph Write the command graph for the build manifest as a graphviz file --build-system \u0026lt;build-system\u0026gt; (default: native) --enable-dead-strip/--disable-dead-strip Disable/enable dead code stripping by the linker (default: true) --static-swift-stdlib/--no-static-swift-stdlib Link Swift stdlib statically (default: false) --version Show the version. -h, -help, --help Show help information. SUBCOMMANDS: clean Delete build artifacts purge-cache Purge the global repository cache. reset Reset the complete cache/build directory update Update package dependencies describe Describe the current package init Initialize a new package _format diagnose-api-breaking-changes Diagnose API-breaking changes to Swift modules in a package dump-symbol-graph Dump Symbol Graph dump-pif dump-package Print parsed Package.swift as JSON edit Put a package in editable mode unedit Remove a package from editable mode config Manipulate configuration of the package resolve Resolve package dependencies show-dependencies Print the resolved dependency graph tools-version Manipulate tools version of the current package generate-xcodeproj Generates an Xcode project. This command will be deprecated soon. compute-checksum Compute the checksum for a binary artifact. archive-source Create a source archive for the package completion-tool Completion tool (for shell completions) plugin Invoke a command plugin or perform other actions on command plugins See \u0026#39;swift help package \u0026lt;subcommand\u0026gt;\u0026#39; for detailed help. 具体使用方法 就像帮助信息中所列的，命令行下使用SPM的格式如下：\nswift package \u0026lt;options\u0026gt; \u0026lt;subcommand\u0026gt; 因为选项太多，我们在具体使用过程中可以在需要的时候从命令行帮助信息中查询，这里我们主要学习下这些子命令的使用方法，关于子命令的具体使用帮助信息，可以使用命令：swift help package \u0026lt;subcommand\u0026gt;在控制台随时进行查询学习\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/framework_integration/interfaceing_with_uikit/",
	"title": "与UIKit交互",
	"tags": [],
	"description": "",
	"content": "SwiftUI可以在苹果全平台上无缝兼容现有的UI框架。例如，可以在SwiftUI视图中嵌入UIKit视图或UIKit视图控制器，反过来在UIKit视图或UIKit视图控制器中也可以嵌入SwiftUI视图。\n本篇教程展示如何把landmark应用的主页混合使用UIPageViewController和UIPageControl。使用UIPageViewController来展示由SwiftUI视图构成的轮播图，使用状态变量和绑定来操作用户界面数据的更新。\n跟着教程一步步走，可以下载工程文件进行实践。\n项目文件 InterfacingWithUIKit.zip (9 MB) 第一节 创建一个用来展示UIPageViewController的SwiftUI视图 为了在SwiftUI视图中展示UIKit视图和UIKit视图控制器，需要创建遵循UIViewRepresentable和UIViewControllerRepresentable协议的类型。创建的自定义视图类型，用来创建和配置所要展示的UIKit类型，SwiftUI框架来管理UIKIt类型的生命周期并在适当的时机更新它们。\n步骤1 创建一个新的SwiftUI视图文件，命名为PageViewController.swift，并且声明PageViewController类型遵循UIViewControllerRepresentable。这个页面视图控制器存放一个UIViewController实例数组，数组中的每一个元素代表在地标滚动过程中的一页视图。\n下一步添加UIViewControllerRepresentable协议的两个实现, 目前因为协议方法没有完成实现，会有报错提示。\n步骤2 添加一个makeUIViewController(context:)方法，方法内部以指定的配置创建一个UIPageViewController。SwiftUI会在准备显示视图时调用一次makeUIViewController(context:)方法创建UIViewController实例，并管理它的生命周期。\n由于还缺少一个协议方法没有实现，所以目前还是会报错。\n步骤3 添加updateUIViewController(_:context:)方法，这个方法里调用setViewControllers(_:direction:animated:)方法展示数组中的第一个视图控制器\n创建另一个SwiftUI视图展示遵循UIViewControllerRepresentable协议的视图\n步骤4 创建一个名为PageView.swift的视图，声明一个PageViewController作为子视图。初始化时使用一个视图数组来初始化，并把每一个视图都嵌入在一个UIHostingController中。UIHostingController是一个UIViewController的子类，用来在UIKit环境中表示一个SwiftUI视图。\n步骤5 更新预览视图，并传入视图数组，预览视图就会开始工作了\n步骤6 在继续下面的步骤前，先把PageView的预览视图固定住，以避免在文件切换时不能实现预览到PageView的改变。\n第二节 创建视图控制器的数据源 短短几个步骤就做了很多事，PageViewController使用UIPageViewController去展示来自SwiftUI内容。现在是时候添加挥动手势进行页面之间的翻动了。\n一个展示UIKit视图控制器的SwiftUI视图可以定义一个Coordinator类型，这个Coordinator类型由SwitUI管理，用来作为视图展示的环境\n步骤1 在PageViewControlelr中定义一个嵌套类型Coordiantor。SwiftUI管理UIViewController Representable类型的coordinator，并在调用方法时把它作为环境的一部分。\n步骤2 在PageView Controller中添加另一个方法，创建coordinator。SwiftUI在调用makeUIViewController(context:)前会先调用makeCoordinator()方法，因此在配置视图控制器时是可以访问到coordiantor对象的。可以使用coordinator为实现通用的Cocoa模式,例如：代理模式、数据源以及目标-动作。\n步骤3 让Coordinator类型添加UIPageViewControllerDataSource协议遵循，并且实现两个必要方法。这两个必要方法会建立起视图控制器之间的联系，因此可以实现页面之前的前后切换。\n步骤4 把coordiantor作为UIPageViewController的数据源\n步骤5 打开实时预览，并测试一下前后页面切换的功能是否正常\n第三节 在SwiftUI视图的状态下跟踪页面 如果要添加一个自定义的UIPageControl控件，就需要一种方式能够在PageView中跟踪当前展示的页面。这就需要在PageView中声明一个@State属性，并传递一个针对该属性的绑定关系给PageViewController视图，在PageViewController中通过绑定关系更新状态属性，来反映当前展示的页面。\n步骤1 在PageViewController中添加一个绑定属性currentPage。除了使用关键字@Binding声明属性为绑定属性外，还需要更新一下函数setViewControllers(_:direction:animated:)，给它传入currentPage绑定属性\n做到这一步还不能正常运行，继续进行下一步。\n步骤2 在PageView中声明@State变量，并在创建PageViewController时把绑定属性传入。注意使用$语法创建一个针对状态变量的绑定关系。\n步骤3 通过改变PageView视图中的currentPage初始值来测试绑定关系是否正常生效。也可以做一个测试按钮，点击按钮时让第二个页面展示出来\n步骤4 添加一个TextView控件来展示状态变量currentPage的值，拖动页面切换时观察TextView上的值，目前不会发生变化。因为PageViewController内部没有在切换页面的过程中更新currentPage的值。\n步骤5 在PageViewController.swift中让coordinator作为UIPageViewController的代理，并添加pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted completed: Bool) 方法。因为SwiftUI在页面切换动画完成时会调用这个方法，这样就可以这个方法内部获取当前正在展示的页面的下标，并同时更新绑定属性currentPage的值。\n步骤6 coordinator除了是UIPageViewController数据源外，再把它赋值为UIPageViewController的代理。由于绑定关系是双向的，所以当页面切换时，PageView视图上的Text就会实时展示当前的页码。\n第四节 添加一个自定义PageControl 我们已经为包裹在UIViewRepresentable视图中的子视图上添加了一个自定义UIPageControl\n步骤1 创建一个新的SwiftUI视图，命名为PageControl.swift，并使用PageControl类型遵循UIViewRepresentable协议。UIViewRepresentable和UIViewControllerRepresentable类型有相同的生命周期，在UIKit类型中都有对应的生命周期方法。\n步骤2 在PageView中用PageControl替换Text,并把VStack换成ZStack。因为总页数和当前页面都已经传入PageControl，所以PageControl已经可以正确的显示。\n下一步要处理PageControl与用户的交互，让它可以被用户点击任意一边进行页面间的切换。\n步骤3 在PageControl中创建一个嵌套类型Coordiantor，添加一个makeCoordinator()方法创建并返回一个coordinator实例。因为UIControl子类(包括UIPageControl)使用Target-Action模式，Coordinator实现一个@objc方法来更新currentPage绑定属性的值。\n步骤4 把coordinator作为PageControl值改变事件的目标处理器，并指定updateCurrentPage(sender:)方法为处理函数\n步骤5 现在就可以尝试PageControl的各种交互来切换页面，PageView展示了SwiftUI和UIKit视图如何混合使用。\n检查是否理解 问题1 下面哪个协议可以用来把UIKit中的视图控件器桥接进SwiftUI？\nUIViewRepresentable UIHostingController UIViewControllerRepresentable 问题2 对于UIViewControllerRepresentable类型，下面哪个方法可以为它创建一个代理或数据源？\n在makeUIViewController(context:)方法中创建UIViewController实例的地方 在UIViewControllerRepresentable类型的初始化器中 在makeCoordinator()方法中 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/app_design_and_layout/composing_complex_interfaces/",
	"title": "组合复杂用户界面",
	"tags": [],
	"description": "",
	"content": "Landmarks应用的首页是一个纵向滚动的\u0008地标类别列表，每一个类别内部是一个横向滑动列表。随后将构建应用的页面导航，这个过程中可以学习到如果组合各种视图，并让它们适配不同的设备尺寸和设备方向。\n项目文件 ComposingComplexInterfaces.zip (6 MB) 第一节 添加一个首页视图 已经创建了所有在Landmarks应用中需要的视图，现在给应用创建一个首页视图，把之前创建的视图整合起来。首页不仅仅包含之前创建的视图，它还提供页面间导航的方式，同时也可以展示各种地标信息。\n步骤1 创建一个名为CategoryHome.swift的自定义视图文件\n步骤2 把应用的场景代理(scene delegate)的根视图从之前的地标列表视图更改为新创建的首页视图。现在应用启动后的每一个页面就是首页了，所以还需要添加从首页导航跳转到其它页面的方法。\n步骤3 添加NavigationView，这个NavigationView将会容纳Landmarks应用中其它不同的视图。配合使用NavigationView、NavigationLink及相关的修改器，就可以构建出应用的页面间导航结构\n步骤4 设置导航栏标题为Featured\n第二节 创建地标类别列表 Landmarks应用为了便于用户浏览各种类别的地标，将地标按类别竖向排列形成列表视图，对于每一个类别内的具体地标，又把它们按照水平方向排列，形成横向列表。组合使用垂直栈(vertical statck)和水平栈(horizontal stack)并给列表添加滚动\n步骤1 使用Dictionary结构体的初始化方法init(grouping:by:)，把地标数据的类别属性category传入作为分组依据，可以把地标数据按类别分组。工程文件中已经为每一个地标样本数据预定义了类别。\n步骤2 使用List显示地标数据的类别。Landmark.Category是枚举类型，它的值标识列表中每一种类别，可以保证类别不会有重复定义\n第三节 添加针对\u0008单个类别的地标行列表 Landmarks应用对每个类别下的地标采用横向滑动的行进行展示。添加一个新的视图类型用来表示这样一个地标行，然后使用这个新创建的行类型具体展示某一具体类型上的所有地标。\n步骤1 定义一个新的视图类型，用来展示地标类别行的内容。新建行视图需要存放地标具体类别的展示数据\n步骤2 更新CategoryHome.swift的代码，把地标类别信息传给新建的行视图类型\n步骤3 在CategoryRow.swift中使用一个HStack展示类别下的地标内容\n步骤4 为行内容指定一个高度，并把行内容嵌入到ScrollView中，以支持横向滑动。预览视图时，可以多增加几个地标数据，用来查看列表的滑动是否正常。\n第四节 组合首页 Landmarks应用的首页在用户点击查看地标详情前需要先把地标的一些简单信息展示出来。复用之前创建的视图构建具体某一类别地标的行视图\n步骤1 在CategoryRow.swift文件中，与CategoryRow类型并列，创建一个新的自定义视图类型CategoryItem，用这个新的视图类型替换CategoryRow的地标名称Text控件\n步骤2 在CategoryHome.swift中，添加一个名为FeaturedLandmarks的简单视图，这个视图用来显示地标数据中isFeatured属性为真的那些地标。在之后的教程中，会把FeaturedLandmarks这个视图修改成一个交互式轮播图。目前，这个视图仅仅展示一张缩放和剪裁后的地标图片。\n步骤3 把\u0008视图的边距设置为0，让展示内容可以尽量贴着屏幕边沿\n第五节 现在所有类别的地标都可以在首页视图中展示出来，用户还需要能够进入应用其它页面的方法。使用页面导航和相关API来实现用户从应用首页到地标详情页、收藏列表页及用户个人中心页的跳转。\n步骤1 在CategoryRow.swift中，把CategoryItem视图包裹在NavigationLink视图中。CategoryItem这时做为跳转按钮的\u0008\u0008内容，destination指定点击NavigationLink按钮时要跳转的目标视图。\n步骤2 使用renderingMode(_:)和foregroundColor(_:)这两个属性修改器来改变地标类别项的导航样式。做为NavigationLink标签的CategoryItem中的文本会使用Environment中的强调颜色，图片可能以模板图片的方式渲染，这些都可以使用属性修改器来调整，达到最佳效果。\n步骤3 在CategoryHome.swift中，添加一个模态展示的用户信息展示页，点击了用户图标时弹出展示。当状态showProfile被置为true时，展示用户信息页，当showProfile状态置为false时，用户信息页消失。\n步骤4 在导航条上添加一个按钮，用来切换showProfile状态的值：true或者false\n步骤5 在CategoryHome.swift中添加一个跳转链接，点击时跳转到全部地标的筛选页面。\n步骤6 把LandmarkList.swift中的把包裹地标列表视图的NavigationView移动到对应的预览视图中。因为在应用中，LandmarkList总是会被展示在CategoryHome.swift定义的导航视图中。\n检查是否理解 问题1 对于Landmarks这个应用来说，哪一个视图是它的根视图？\nSceneDelegate Landmarks CategoryHome 问题2 CategoryHome这个视图是如何与应用的其它视图联动起来的\n在不同地标之间复用图片资源 与其它视图使用一致的命名规范和属性修改器语法 使用导航结构把地标应用中所有视图连接在一起 问题3 下面哪段代码可以将一个普通视图转化为一个具体点击导航功能的视图\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/drawing_and_animation/drawing_paths_and_shapes/",
	"title": "绘制路径和形状",
	"tags": [],
	"description": "",
	"content": "用户在浏览完一个地标后会得到一个徽章。但用户要得到徽章首先要先要创建一个徽章。本篇教程就是使用路径和形状创建徽章的过程，创建的徽章可以和其它图形组合形成位置标志。\n如果想要针对不同种类的地标创建不同的徽章，可以尝试改变徽章基本组成符号的重复次数、角度或大小。\n跟着教程一步步走，可以下载工程文件进行实践。\n项目文件 DrawingPathsAndShapes.zip (6 MB) 第一节 创建徽章视图 创建徽章前需要使用SwiftUI的矢量绘画API创建一个徽章视图\n步骤1 选择文件-\u0026gt;新建-\u0026gt;文件，然后从iOS文件模板列表中选择SwiftUI View。点击下一步(Next)，输入文件名Badge后点击创建(Create)\n步骤2 调整Badge视图，暂时先让它显示\u0026quot;Badge\u0026quot;文本，一会儿再绘制徽章的形状\n第二节 绘制徽章背景 使用SwiftUI的图形API绘制一个徽章形状\n步骤1 查看在文件HexagonParameters.swift中的代码。HexagonParameters结构体定义了绘制徽章六边形形状的控制点参数。不需要修改这些绘制相关的数据，仅仅使用这些数据指定绘制徽章形状时，线段和曲线的控制点位置。\n步骤2 在Badge.swift文件中，绘制徽章的形状并使用fill修改器给六边形填充颜色，形成一个视图。使用路径可以把多条直线、曲线或其它绘制形状的基本笔划连成一个复杂的图形，就像形成徽章六边形背景这样.\n步骤3 给路径添加起点，move(to:)方法可以把绘图光标移动到绘图中的一点，准备\u0008绘制的起点\n步骤4 使用六边形的绘制参数数据HexagonParameters，依次绘制六边形的边，形成大致轮廓.addLine(to:)方法会使用当前绘图光标所在点为起点，方法参数中指定的点为终点绘制直线。目前六边形看\u0008起来有点问题，不过不要担心，这是意料中的事，下面的步骤做完，六边形的形状就会和开头显示的徽章的六边形形状一致了\n步骤5 使用addQuadCurve(to:control:)方法绘制\u0008贝塞尔曲线，让六边形的角变的更圆润些。\n步骤6 把徽章路径包裹在一个Geometry Reader中，这样徽章可以使用容器的大小，定义自己绘制的尺寸，这样就不需要硬编码绘制尺寸了(100)。当绘制区域不是正方形时，使用绘制区域的最小边长(长宽中哪个最小使用哪个)作为绘制徽章背景的边长，并保持徽章背景的长宽比为1:1\n步骤7 使用xScale和xOffset参数调整变量，把徽章几何绘图区域居中\u0008绘制出来\n步骤8 把黑色实心填充色改为渐变色，使徽章看上去和开始设计的样式一致\n步骤9 渐变色上再使用aspectRatio(_:contentMode:)修改器，让渐变色按内容\u0008宽高比进行成比例渐变填充。保持1:1的长宽比，徽章背景可以保持居中在徽章视图中，不管徽章视图本身是不是正方形\n第三节 绘制徽章符号 地标徽章中心有一个以地标App图标中的山峰图形改造形成的标志。山峰这个符号由两个形状组成，一个是表示山顶被雪覆盖的部分，另一个是山体。这里会使用有一定间距的两个局部三角形形状绘制这个徽章符号\n步骤1 把之前的徽章视图形状抽出来单独形成一个BadgeBackground视图，并生成一个新的视图文件BadgeBackground.swift\n步骤2 把BadgeBackground放在Badge的body属性中。\n步骤3 创建名为BadgeSymbol的自定义视图，这个视图是一个山峰的形状，把这个形状复制多次并按一定角度旋转多次拼成一个徽章的图案\n步骤4 使用\u0008pathAPI来绘制徽章符号的上半部分，试着调节spacing、topWidth、topHeight的系数，观察这些系数是怎么影响图形绘制的结果的\n步骤5 绘制徽章图案的下半部分，使用move(to:)把绘图光标移到另一个图形绘制的起点，绘制新的形状\n步骤6 用紫色填充徽章符号\n第四节 组合徽章的前景符号和背景形状 徽章设计思路是在背景形状上面再绘制多个有固定旋转角度的山峰符号。定义一个新的类型用于展示旋转一定角度的徽章符号，使用ForEach生成不同旋转角度的山峰符号，绘制在徽章背景上，从而形成最终的徽章。\n步骤1 创建RotatedBadgeSymbol视图封装旋转徽章符号，调整旋转的角度，并在预览视图中查看效果\n步骤2 在Badge.swift中，使用ZStack把徽章图标放在徽章背景层上面。此时会发现，徽章符号的尺寸相比徽章背景大了许多，这不符合最初设计的预期\n步骤3 缩放符号尺寸到合适的大小\n步骤4 使用ForEach复制多个徽章图标，按360度周解均分，每一个徽章符号都比前一个多旋转45度，这种就会形成一个类似太阳和徽章图标\n检查是否理解 问题1 GeometryReader的作用是什么?\nGeometryReader可以把父视图分割成网格，便于在屏幕上布局视图 GeometryReader可以动态的绘制、定位、缩放视图，不需要写死它们的尺寸。这样可以在不同尺寸的屏幕上复用已经写好的视图 使用GeometryReader可以自动识别\u0008应用视图层级上形状的类型和位置，例如: (圆)Circle 问题2 下面代码段布局后是哪一个图？\n问题3 下面代码绘制出哪个图？\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/swiftui_essentials/creating_and_combining_views/",
	"title": "创建和组合视图",
	"tags": [],
	"description": "",
	"content": "这个教程指导你构建一个名为Landmarks(地标)的应用。这个应用的功能是可以发现并分享你喜欢的地标。首先从创建地标详情页开始。\nLandmarks使用栈来按层组合图片、文本等视图元素，从而布局页面。在视图中添加地图，需要引入MapKit组件，在你布局页面的过程中， Xcode可以提供实时的反馈，让你所做的改动立即转化成对应的代码实现。\n项目文件 CreatingAndCombiningViews.zip (785 KB) 第一节 创建新项目并体验画布 创建SwiftUI项目工程，体验画布、预览模式和SwiftUI模板代码\n要想在Xcode中预览画布中的视图或者与画布中的视图进行交互，要求你的Mac系统版本号不低于macOS Catalina 10.15\n步骤1 打开Xcode，在启动页面点击创建新工程或者在菜单中选择文件-\u0026gt;新建-\u0026gt;项目\n步骤2 在项目模板选择器中，选择iOS作为项目平台，选项单视图应用(Single View App)作为项目模板，并点击下一步(Next)\n步骤3 输入Landmarks作为项目名称，选择SwiftUI作为用户界面的创建方式，并点击下一步(Next)，在磁盘目录下选择一个位置用来存放新创建的工程项目\n步骤4 工程创建好并打开后，在文件导航器中，选择ContentView.swift文件，可以浏览一下SwiftUI视图的组成结构。默认情况下，SwiftUI的视图文件包含两个结构体(Struct) 第一个结构体遵循View协议，描述视图的内容和布局。第二个结构体声明为第一个视图的预览视图。\n步骤5 在**画布(Canvas)上，点击恢复(Resume)**按钮可以显示预览视图，也可以使用快捷键Command+Option+P\n如果工程中没有出现画布(Canvas)，可以选择菜单:编辑器(Editor) -\u0026gt; 编辑器和画布(Editor and Canvas) 打开画布进行预览\n步骤6 在body属性内部，修改文字Hello World为其它的不同的文字，当你在改变代码的同时，预览视图也会实时的更新对应的内容变化\n第二节 定制文本视图(Text View) 可能通过修改代码来改变一个视图的显示样式，也可以通过检查器获取视图可修改属性，然后再写对应的代码改变样式。在创建应用的过程中，可以同时使用源码编辑器、画布或者检查器，无论当前使用的是哪一个工具编辑视图，代码会保持和这些编辑器展示的样式一致\n下面我们使用检查器来定制视图的显示样式\n步骤1 在预览视图中，按下Command键的同时点击控件，会弹出一个编辑弹层，然后选择检查器(Inspect), 编辑弹层显示所有可以定制的视图属性，选中的控件不同，可以定制的属性集合也不相同\n步骤2 使用检查器把文字更改为Turtle Rock，也就是在应用中显示的第一个地标的名称\n步骤3 改变字体修改器为Title，使用系统字体修饰文字，可以自动按照用户在设备中设置的字体偏好大小进行调整。定制SwiftUI视图所调用的方法被称为视图修改器(Modifiers)，修改器在原视图的基础上修改部分显示样式和属性，返回一个新的视图，这样就可以让多个修改器串连进行，形成水平方向的链式调用，或者垂直方向的堆叠调用\n步骤4 手动在代码中添加foregroundColor(.green) 属性修改器，就会把文字的颜色调整为绿色。代码是决定视图样式的根本，当我们使用检查器来改变或移除一个属性修改器时，Xcode也会在代码编辑器中同步改变或移除对应的修改器代码\n步骤5 在代码编辑器中，按下Command的同时点击Text单词也可以属性弹窗，从中选择检查器后，再点击Color弹出菜单，选择继承(Inherited)，让文字的颜色恢复成原来的黑色\n步骤6 当我们移除 foregroundColor(.green) 时，Xcode会自动更新你的代码来反映视图的实际显示状况\n第三节 使用栈来组合视图 上一节创建了标题视图，接下来要添加一些文本视图来描述地标所在州及所在公园的名称等其它详细信息\n创建SwiftUI视图就是在body属性中描述视图的内容、布局及行为，但body属性只返回单个视图，这时\u0008组合多个视图时可以把它们放入一个栈中，通过水平、垂直、前后嵌套多个视图完成视图组合，做为一个整体在body属性中返回\n这一节中，使用一个垂直栈，把标题放在包含公园详情的水平栈的上方，在水平栈中，布局公园详情相关的内容\n可以使用Xcode提供的结构化布局来把视图嵌套在容器视图中\n步骤1 按下Command键的同时，点击Text视图的初始化代码打开结构化编辑弹窗，然后选择把控件嵌套在垂直栈中(Embed in VStack)，在栈中添加Text View控件可以从组件中直接拖进栈中完成\n步骤2 点击Xcode右上角的**+**号，托动一个Text控件到指定位置，代码立即就会在编辑器中补全\n步骤3 把Text视图的占位文本修改为Joshua Tree Nation Park，视图会自动调整位置布局\n步骤4 设置位置控件的字体为子标题样式\n步骤5 设置VStack初始化参数为左对齐内部的子视图。默认情况下，栈会把内部视图在自己的主轴上居中对齐，并自动计算各子视图的间距。下一步要添加一个Text控制用来描述公园的状态，它水平排列在位置信息的右边。\n步骤6 在\u0008\u0008画布内，command按下的同时点击位置视图，在弹出的菜单中选择嵌入到水平栈中(Embed in HStack)\n步骤7 在位置控件的后面加一个公园状态的Text视图，并把占位文字改为California，字体设置为子标题样式\n步骤8 为了水平布局使用整个屏幕宽度，在位置控件和公园状态控件中间添加一个Spacer控件，用来填充两个控件中间的空白部分，并把两个控件分别顶向屏幕的两侧。Spacer是一个可以伸缩的空白控件，他负责占用其它控件布局完成后剩下的所有空间。\n步骤9 使用padding()修改器给地标信息内容视图整体加内边距\n第四节 创建自定义图像视图(Image) 有了地标名称、地标位置及状态视图，下一步再添加一个地标图片视图。这个图片视图将自定义遮罩(mask)、边框(border)和阴影(shadow)\n从控件加中拖一个Image到画布，或直接写代码到代码编辑器中\n步骤1 在项目资源文件中找到turtlerock.png图片，把它拖入资源编辑器(asset catalog editor)中，Xcode会创建一个新的图片集来存放这个图片，然后创建一个SwiftUI视图\n步骤2 选择文件-\u0026gt;新建-\u0026gt;文件，打开模板选择器。在用户界面(User Interface)板块下，选择SwiftUI View并点击下一步，命名为CircleImage.swift，并点击创建(Create)。现在你已经准备好插入图片并修改布局来满足设计目标\n步骤3 用Image替换Text，并使用turtlerock图片初始化Image视图\n步骤4 添加clipShape(Circle())修改器到Image，给图片添加圆形剪切效果。Circle是一个形状，它可以被用作遮罩、也可以是圆圈，还可以是圆形\u0008填充视图。\n步骤5 创建另一个灰色的圆圈并把它作为一个浮层添加到图片上，相当于给图片加了一个灰色边框\n步骤6 给视图添加半径为10的阴影\n步骤7 把圆形边框的颜色改成白色，就完成了自定义图片视图的创建。\n第五节 UIKit视图与SwiftUI视图混合使用 现在要创建一个地图视图，可以使用MapKit中的MKMapView视图类来渲染地图。要在SwiftUI中使用UIView及其子类，需要把这些UIView包裹在一个遵循UIViewRepresentable协议的SwiftUI视图中，SwiftUI中也包含适配WatchKit和AppKit的类似的协议。\n首先需要创建一个自定义视图用来容纳和显示MKMapView\n步骤1 选择文件-\u0026gt;新建-\u0026gt;文件，选择iOS平台，选择SwiftUI View模板，并点击下一步(Next)，命名文件为MapView.swift，并点击创建(Create)\n步骤2 代码中导入MapKit引用，声明MapView遵循UIViewRepresentable协议。UIViewRepresentable协议要求实现两个方法makeUIView(context:)和updateUIView(_:context:)，第一个方法用来创建MKMapView，第二个方法用来配置视图响应状态变化\n步骤3 替换body，用makeUIView(context:)方法来代替，创建并返回一个空的MKMapView\n步骤4 创建方法updateUIView(_:context:)，在方法内部设置地图视图的坐标为Turle Rock的中心。在静态模式下预览时，只会渲染swiftUI视图的部分，因为MKMapView是UIView的子类，所以需要切换到实时预览模式下才能看到地图被完全渲染出来\n步骤5 点击Live Preview(实时预览)按钮，可能需要点击Try Again和Resume按钮来激活预览模式的切换。切换到实时预览模式下不久就可以看到\u0008指定地标所在的地图位置了\n第六节 组合地标详情页 前面我们创建了个地标详情页所需要的各种子视图元素：名称、地点、圆形图片以及位置地图，现在可以把这些视图元素组合在一起形成地标详情页的整个视图\n在项目工程浏览器中选择ContentView.swift文件\nbody属性中嵌入一个VStack视图，它内部包含另一个VStack视图，内部的VStack视图又包含三个Text视图\n在外层VStack的顶部添加自定义的地图视图MapView，并使用frame(width:height:)设置视图大小。当只指定高度时，宽度会自动计算为父视图的宽度，在这里就是屏幕宽度\n点击Live Preview按钮进入实时预览模式，查看地图渲染情况。在实时预览模式下可以编辑视图，最新的改动也可以实时的刷新出来。\n在MapView后面再添加一个CircleImage视图\n为了让图片视图叠放在地图视图的上面，可以设置图片视图的垂直偏移量为-130，图片视图的底部内边距也为-130，这个效果就是把图片垂直上移了130，同时和下面的文字区域留出了130的空白分隔区\n在外层VStack内部的最下面加上Spacer，可以让上面的视图内容顶到屏幕的上边\n为了让地图的视图内容显示在状态栏的下方，可以给MapView添加edgesIgnoringSafeArea(.top)修改器，这可以让它在布局时忽略顶部的安全区域边距\n检查是否理解 问题1 在声明自定义SwiftUI视图时，视图布局要声明的在哪里？\n在视图初始化器中 body属性中 layoutSubviews方法中 View协议中要求实现body属性，每一个SwiftUI视图都遵循View协议\n问题2 代码布局的视图是以下哪个？\n问题3 下面哪种方法是从body属性中返回三个视图的正确方法？\n问题4 配置视图时，下面哪种是正确使用修改器的方式？\n修改器每次都是返回一个新的对象，所以多个修改器可以通过链式调用\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftpm/spm_in_xcode/",
	"title": "Xcode中的SPM",
	"tags": [],
	"description": "",
	"content": "Xcode本身自带Swift工具链，从Swift 3.0开始，已经集成了Swift Package Manager功能，所以安装成功后就可以直接使用SPM相关功能\n在Xcode中使用SPM功能，主要是通过图形界面进行操作的\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/framework_integration/creating_a_watchos_app/",
	"title": "创建watchOS应用",
	"tags": [],
	"description": "",
	"content": "这篇教程让我们可以应用之前所学到的SwiftUI知识，把Landmarks应用从iOS平台迁移到watchOS平台上。在拷贝可以共用的数据和视图文件之前，需要先给项目中添加一个对应watchOS的Target编译目标，assets资源保持原状，只需要调整SwiftUI视图以适应在watchOS平台上展示就可以了。\n按照下面的步骤构建工程，或者下载完成后的项目文件学习。\n项目文件 CreatingAwatchOSApp.zip (9 MB) 第一节 添加一个watchOS编译目标 要创建一个watchOS应用，第一步是给项目添加一个对应watchOS平台的编译目标。Xcode在新增Target的同时，添加一个文件组和相应的文件到工程中，同时还会新增编译运行方案，指定应用要运行的平台或模拟器。\n步骤1 选择菜单File-\u0026gt;New-\u0026gt;Target。当模板列表出现后，在watchOS选项卡下选择Watch App for iOS App模板，并点击下一步(Next)。\n选择这个模板会添加一个新的watchOS应用到工程中，嵌入到iOS应用平级。\n步骤2 在模板创建表中，输入WatchLandmarks作为产品名称，设置语言为Swift，用户界面为SwiftUI实现方式，并勾选通知应用场景，最后点击完成(Finish)。\n步骤3 如果Xcode提示激活watchOS平台编译运行方案，点击激活(Activate)。这会把编译运行方案从iOS平台切换到watchOS平台上来。\n步骤4 在扩展TargetWatchLandmarks Extensions的通用(General)选项卡下勾选Supports Running Without iOS App Installation，尽量创建一个可以独立于iOS宿主运行的watchOS应用。\n第二节 在Target间共享文件 现在watchOS平台的编译目标(Target)已经创建好，为了避免重复工作，可以复用一些之前在iOS项目中的资源。地标的数据模型文件可以复用，一些资源文件以及一些两个平台下不需要修改就可以展示的视图文件也可复用。\n步骤1 在项目导航器中，按下Command+鼠标左键的同时，选中文件：LandmarkRow.swift、Landmark.swift、UserData.swift、Data.swift、Profile.swift、Hike.swift和CircleImage.swift。\n其中Landmark.swift、UserData.swift、Data.swift、Profile.swift、Hike.swift这几个文件定义了应用的数据模型。我们不会使用这些文件中的所有内容，但为了编译通过需要这些文件。LandmarkRow.swift、 CircleImage.swift这两个文件是不需要任何修改就可以在watchOS平台上展示的视图。要注意Data.swift文件中是否导入ImageIO模块，如果没有import ImageIO这一句，编译时会有报错。\n步骤2 上一步选中需要文件的情况下，在文件检查器中，勾选WatchLandmarks Extension，让之前选中的文件也变成WatchLandmarks Extension编译时用到的文件。\n步骤3 在项目导航器中，选中Landmarks文件组下的Assets.xcassets文件，并在文件检查器中把它添加到WatchLandmarks编译运行目标中。这里的编译运行目标和上一步选中的编译运行目标不相同。WatchLandmarks Extension是用来放置应用的代码，WatchLandmarks是用来管理storyboard、图标以及相关资源的。\n步骤4 在项目导航器中，选择Resources文件夹下的所有文件，并在文件检查器中把它们添加到WatchLandmarks Extension编译目标下。\n第三节 创建详情视图 iOS编译目标下的资源可以在手表应用下使用，但我们需要创建一个专门适配手表尺寸的地标详情页来展示地标的具体信息。为了测试视图是否能适配手表展示，需要分别为最大尺寸和最小尺寸手表创建预览视图，并根据情况适当的调整圆形视图的布局来适应手表的界面大小。\n步骤1 在项目导航器中，点击WatchLandmarks Extension文件夹左边的三角形展开箭头，查看文件夹下的具体内容，并添加一个名为WatchLandmarkDetail的SwiftUI视图。\n步骤2 在结构体WatchLandmarkDetail结构体中添加userData、landmark和landmarkIndex属性。这些新增和属性与在处理用户输入时在LandmarkDetail中添加的属性是对等的。\n添加完属性后发现，Xcode会报缺少参数的错误。要修复这个错误有两种方式，一种是为属性提供一个默认值，一种是给视图的属性传入对应的值。\n步骤3 在预览视图中，创建一个用户数据的实例，并给WatchLandmarkDetail结构体的初始化器中传入一个地标对象作为参数。这里需要把用户数据设置为视图的环境对象。\n步骤4 在WatchLandmarkDetail.swift文件中，body()方法中返回一个CircleImage视图。这里的CircleImage是复用iOS项目中的视图，因为创建的图片是可缩放的，可以调用.scaleToFill()属性修改器让圆的大小添满整个手表显示屏。\n步骤5 创建最大尺寸(44mm)和最小尺寸(38mm)的手表预览视图。通过测试在最大最小尺寸上的展示情况，查看应用UI是否有问题，通常情况下，需要测试所有不同尺寸显示屏上UI展示情况是否符合预期。\nCircleImage缩放到高度完全填充显示器高度，但这种情况下适配了高度，宽度却被截断了。为了修复这个截断问题，需要把CircleImage视图嵌入到一个VStack视图容器中，并作一些调整，让CircleImage可以在所有尺寸的手表显示屏上正常展示。\n步骤6 把CircleImage嵌入到VStack中，并在图片下方显示地标名称信息。\n很明显，此时的信息一屏展示不下，所以需要把视图内容放入到ScrollView中，以获取滚动查看的功能。\n步骤7 把VStack整体嵌入到一个ScrollView中，这就让视图获取了滚动查看的能力，但同时也引入了另一个问题：CircleImage现在扩展到完全尺寸，把其它元素挤到没有地方显示。所以需要缩放CircleImage，让圆形图片和地标名称可以在一屏内同时显示出来。\n步骤8 改变scaleToFill()为scaleToFit()，这就让图片缩放按照显示器的宽度进行适配。\n步骤9\n为了让地标名称在地标图片的下面展示了来，添加padding量来解决。\n步骤10 给返回按钮添加一个标题文本。这个返回按钮是看不见的，只有把LandmarksList视图加上后，才会出现返回按钮。\n第四节 添加一个watchOS地图视图 既然已经创建了详情页，现在就可以添加一个地图视图用来显示地标的地理位置了。不像CircleImage，这里就不能复用iOS应用的MapView了。需要创建一个WKInterfaceObjectRepresentable结构体来包装一个WatchKit地图。\n步骤1 在WatchKit Extension中添加一个名为WatchMapView的视图。\n步骤2 让WatchMapView遵循WKInterfaceObjectRepresentable协议而不是View协议。\n目前，因为还没有实现协议WKInterfaceObjectRepresentable协议的方法，所以Xcode会报错。\n步骤3 删除body()方法，并用属性landmark替换它。当创建一个地图视图时，需要给这个landmark属性传入一个值。像在预览视图中传入一个地标实例数据一样。\n步骤4 实例协议WKInterfaceObjectRepresentable方法makeWKInterfaceObject(context:)。这个协议方法创建WatchKit地图视图WatchMapView。\n步骤5 实现协议方法updateWKInterfaceObject:(_:, context:)，根据地标的坐标设置地图展示区域，现在项目可以编译通过了。\n步骤6 在WatchLandmarkDetail.swift文件中把WatchMapView添加在VStack的底部。在地图上面添加一上分割器。使用.scaledToFit()和.paddding()来修改地图尺寸，让它更适合屏幕。\n第五节 创建跨平台列表视图 对于地标列表，可以复用iOS应用中列表的行元素视图，但不同的平台下需要展示适合平台的详情页。这就需要把LandmarkList视图转换成一个通用的列表视图。\n步骤1 在工具条中，选择Landmarks方案，让Xcode现在的编译运行方案指向iOS平台。这样做是为了确保对LandmarkList视图的重构不会影响原来在iOS平台时的表现，这样就可以在不影响iOS平台的条件下，把LandmarkList重构后应用到watchOS应用中。\n步骤2 切换到文件LandmarkList.swift，把类型声明为范型。改造为范型后，当要创建一个LandmarkList结构的实例时，会报范型参数类型无法推断的错误。这将在下面的步骤中解决。\n步骤3 添加一个闭包属性，用来创建详情视图。\n步骤4 使用detailViewProducer属性为地标创建详情视图。当需要创建一个LandmarkList时，需要提供一个闭包来创建对应地标的详情视图\n步骤5 切换到Home.swift文件，在CategoryHome结构体的body属性中添加一个闭包用来创建详情视图。Xcode会根据闭包的返回值类型推断出LandmarkList结构体的范型参数类型。\n步骤6 在LandmarkList.swift文件中，给预览视图添加相似的代码。为了适配不同的设备平台，这里需要使用条件编译，为不同平台编译不同的代码。\n第六节 添加地标列表 目前已经将LandmarkList视图改造为可以同时兼容watchOS和iOS两个平台，现在就可以把它应用在watchOS平台下的应用中了。\n步骤1 在文件检查器中，将LandmarkList.swift添加为WatchLandmark Extension编译目标的成员。现在就可以在watchOS的应用中使用LandmarkList.swift这份代码文件了。\n这一步其实在**第五节步骤六**已经做过了。\n步骤2 在工具条上，切换编译方案为Watch Landmarks\n步骤3 打开LandmarkList.swift文件，并对该视图进行预览. Command + Option + Enter打开预览画布，Command + Option + P启动预览。因为现在编译方案已经切换为watchOS平台，所以现在预览视图里显示的是手表预览。watchOS平台的应用根视图是ContentView，目前显示的是Hello, World文字。\n步骤4 修改ContentView让它显示地标列表\n步骤5 在模拟器上构建并运行watchOS应用。滚动地标列表，点击查看地标详情，标记地标为收藏状态，点击返回按钮从地标详情页返回到地标列表页，打开收藏开关，只查看补收藏的地标。测试一下watchOS应用的功能是否正常。\n第七节 创建自定义通知界面 watchOS平台的Landmarks应用已经接近完成了。在最后一节中，会创建一个通知界面，当用户的地理位置靠近自己收藏过的地标位置时会收到通知提示用户，通知界面展示当前正在接近的地标相关信息。本节只讲当用户收到通知时怎样显示通知界面，不涉及怎样设置和发送通知给用户的内容。\n步骤1 打开NotificationView.swift文件并创建一个显示地标信息、标题及消息的视图。由于任何通知都可能为nil，预览视图会展示两种不同的通知视图。第一个展示在没有数据时按默认值显示的视图，第二个展示有标题、消息及位置数据时的视图。\n步骤2 打开NotificationController添加landmark、title和message属性。这些属性值存储用户收到的通知值。\n步骤3 更新body()方法，在其内部使用这些属性。在body方法内初始化之前创建的NotificationView。\n步骤4 在NatificationController中定义LandmarkIndex键，使用这个键从通知中提取地标的下标值。\n步骤5 使用didReceive(_:)方法从收到的通知中解析相关数据值。这个方法会更新控件器的属性值。调用这个方法后，系统会让控制器的body属性失效，引起导航视图更新，之后系统会把通知界面显示在Apple Watch上。\n当Apple Watch接收到通知时，它会创建NotificationController并把它与通知的类型关联起来。为了给NotificationController设置类型，必须打开并编辑应用的storyboard。\n步骤6 在项目导航器中，选择WatchLandmarks文件夹，并打开Interface.storyboard文件，然后选中指向静态通知界面控制器(static notification interface controller)的箭头。\n步骤7 在属性检查器中，设置通知类别的名称为LandmarkNear\n使用LandmarkNear类别配置测试数据(payload)，并把它传给NotificationController\n步骤8 项目导航器中选中WatchLandmarks Extensions文件夹，打开Push NotificationPayload.apns文件，更新title、body、category和landmarkIndex属性值。确保设置category为LandmarkNear。除此之外还需要删除所有在本教程中不需要的其它无关字段，例如subtitle、WatchKit Simulator Actions和customKey。Payload文件是用来模拟从服务端发送的远程推送的数据。\n步骤9 选择编译方案WatchLandmarks(Notificaton)，编译并运行应用。第一次运行通知方案时，系统会请求发送通知的权限，选择允许(Allow)获取发送通知的权限。模拟器会展示一个可滚动的通知：一个标识应用身份的横幅、通知视图以及一个点击按钮用来响应通知被点击后的动作。\n检查是否理解 问题1 当要在iOS工程中添加一个watchOS编译目标时，应该选用哪个应用模板?\nApp Watch App for iOS App Game App 问题2 下面哪一个watchOS应用元素可以通过使用SwiftUI来实现？\n只用watchOS应用的视图可以使用SwiftUI实现 watchOS应用的视图以及自定义通知界面 watchOS应用的视图、自定义通知界面以及complications watchOS应用的视图、自定义通知界面、complicatons以及Siri卡片 问题3 为什么不能在watchOS平台上复用LandmarkDetail视图？\n因为LandmarkDetail视图是为大屏设备设计的 因为watchOS的用户界面应该只展示最重要的信息，并提供访问额外详情的快速访问方式 MapView不能在watchOS上使用，因为它遵循UIViewRepresentable协议，这个协议在watchOS平台上不可用 以上所有 问题4 为什么需要针对watchOS平台来修改LandmarkList视图？\n当用户点击列表中的某一项时，需要改变列表展示的详情视图 LandmarkList不包含任何平台相关的代码，所以要针对不同平台进行不同的布局 要支持多平台，必须使用范型 必须为每个平台重新设计视图 问题5 哪一个通知界面可以使用SwiftUI开发？\n只有动态交互界面可以 静态和动态交互界面都可以 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/app_design_and_layout/working_with_ui_controls/",
	"title": "玩转UI控件",
	"tags": [],
	"description": "",
	"content": "在Landmarks应用中，用户可以创建一个简介来描述他们自已的个人情况。为了让用户可以编辑自己的简介，我们需要添加一个编辑模式并设计一个偏好设置界面。\n这里使用多种通用控件来展示用户的各种数据，并在用户保存他们所做的数据修改时更新地标数据模型。\n按照步骤在下面的项目工程中一步步进行实践。\n项目文件 WorkingWithUIControls.zip (6 MB) 第一节 展示用户简介 Landmarks应用在本地存储了一些配置和用户偏好设置。在用户编辑这些数据前，会被展示在一个没有编辑按钮的概要视图上。\n步骤1\n在项目文件导航栏的Landmarks文件组下面新建一个名为Profile的文件组，并在这个新建的文件组下面添加一个新视图ProfileHost, 这个新视图包含一个TextView，用来展示用户名称。ProfileHost将会展示静态概要信息，同时支持编辑模式\n步骤2 用步骤1创建的ProfileHost替换Home.swift中的静态文本Text视图。现在主页中的profile按钮点击时可以调起一个用户简介页面了\n步骤3 创建一个新的视图命名为ProfileSummary，它会持有一个Profile实例，并显示一些用户的基本信息。Profile概要视图持有一个Profile对像的原因是，因为它的父视图ProfileHost管理着视图的状态，它不能与Profile进行绑定。\n步骤4 更新ProfileHost文件，显示新的概要视图\n步骤5 创建一个名为HikeBadge的新视图，这个新视图由Badge视图和一些描述性文字构成。Badge仅仅是一个图形，在HikeBadge视图中的文本与accessibility(label:)属性修改器一起，可以让这个徽章对用户更加清晰。注意frame(width:height:)的两种不同的用法用来配置徽章以不同的缩放尺寸显示。\n步骤6 更新ProfileSummary文件，添加几个不同的徽章代表用户得到的不同徽章\n步骤7 把HikeView包含在ProfileSummary页面中后，就完成了第一节的实践内容了。\n第二节 添加编辑模式 用户需要能够在浏览模式和编辑模式之间进行切换来查看或者修改用户简介的信息。通过在ProfileHost上添加一个Edit Button，然后创建一个用来编辑简介信息的页面。\n步骤1 添加一个Enviornment视图属性，用来使用\\.edit模式。可以使用这个属性来读写当前编辑模式。\n步骤2 创建一个编辑按钮，可以切换编辑模式\n步骤3 更新UserData类，包含一个Profile实例，即使用户简介页面消失后也可以存储编辑后的信息\n步骤4 从环境变量中读取用户简介信息，并把数据传递给ProfileHost视图的控件上进行展示。为了在编辑状态下修改简介信息后确认修改前避免更新全局状态(例如在编辑用户名的过程中)，编辑视图在一个备份属性中进行相应的修改操作，确认修改后，才把备份属性同步到全局应用状态中。\n步骤5 添加一个条件视图，可以用来显示静态用户简介视图或者是用户简介视图的编辑模式。当前的编辑模式只支持静态文本框的编辑。\n第三节 定义简介编辑器 用户简介编辑器包含几个单独的控件用来修改对应简介信息。在简介中，一些项例如徽章是不可以编辑修改的，所以它们不会出现在简介编辑器中。为了保持简介在编辑模式和浏览模式的一致性，需要按照简介页面各项相同的顺序进行添加。\n步骤1 创建一个名为ProfileEditor的新视图，并绑定用户简介中的草稿。视图中的第一个控件是TextField，用来更新用户名字段值。创建TextField时要提供一个标签和一个绑定字符串。\n步骤2 更新ProfileHost中的条件内容，让它包含条件编辑器并把简单的绑定关系传递给简介编辑器。现在当你点击Edit按钮，简介视图就会变成编辑模式了。\n步骤3 添加一个切换开关，用来设置用户是否接收相关地标事件的推送通知。这个Toggle控件打开和关闭正好对应着布尔值的true或false。\n步骤4 把一个Picker和一个Text放在VStack结构里，让这个地标可以选择不同季节。\n步骤5 最后，在季节图片选择器下方添加一个DatePicker，用来修改地标的目标浏览日期\n第四节 延迟编辑传播 在编辑模式时，使用用户简介信息的备份进行修改，当用户确认进行修改后，再用修改的备份信息覆盖真正的用户信息。直到用户退出编辑模式前都不让编辑的备份生效。\n步骤1 在ProfileHost视图上添加一个取消按钮。不像编辑模式按钮提供的完成按钮，取消按钮不会应用修改后的简介备份信息到实际的简介数据上。\n步骤2 当用户点击完成按钮后，使用onAppear(perform:)和onDisappear(perform:)来更新或保存用户简介数据。下一次进入编辑模式时，使用上一次的用户简介数据来展示。\n检查是否理解 问题1 编辑状态改变时，怎样更新一个视图，例如，当用户编辑了用户简介信息后点击完成按钮的情况下，是怎么更新一个视图的\n问题2 什么情况下需要添加一个accessiblity标签，使用accessibility(label:)修改器?\n在应用的每一个视图都添加一个accessibility标签 当可以让用户界面元素对用户变的更清晰时，添加一个accessibility标签 只有当你没有给视图清加tag时才可以使用accessibility(label:) 问题3 模态和非模态视图展示有什么差别？\n当模态展示一个视图时，源视图设置目标视图的编辑模式 当非模态展示一个视图时，目标视图会盖住源视图并且替代当前的导航栈 当模态展示一个视图时，目标视图盖住源视图并替换当前导航栈 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/drawing_and_animation/animating_views_and_transitions/",
	"title": "视图动画和转场",
	"tags": [],
	"description": "",
	"content": "使用SwiftUI可以把视图状态的改变转成动画过程，SwiftUI会处理所有复杂的动画细节\n在这篇中，会给跟踪用户徒步的图表视图添加动画。\u0008使用animation(_:)修改器给一个视图添加动画效果非常容易\n下载起步项目并跟着本篇教程一步步实践，或者查看本篇完成状态时的工程代码去学习\n项目文件 AnimatingViewsAndTransitions.zip (6 MB) 第一节 给每个视图单独添加动画 在视图上使用animation(_:)修改器时，SwiftUI会在视图的任何可进行动画的属性发生改变时产生对应的动画效果。视图的颜色、不透明度、旋转角度、大小及一些其它属性都是可进行动画的\n步骤1 在HikeView.swift中，打开实时预览，体验一下图表的打开和隐藏，此时的状态改变时是没有添加动画效果的。在本篇的实践中，保持实时预览一直打开，每一步修改的效果就可以实时的看到\n步骤2 给显示/隐藏切换的箭头按钮添加旋转动画，会发现现在按钮点击时的旋转有一个动画过渡的效果了\n步骤3 当视图从隐藏到展示时，让切换按钮变大1.5倍\n步骤4 把动画的类型从easeInOut改为spring()。SwiftUI包含一些预设或可自定义的动画类型，像弹簧(spring)动画和类型液体(fluid)动画类型。可以调整动画开始前的等待时长、动画的速度也可以指定让动画循环重复的进行\n步骤5 如果只想让按钮具有缩放动画而不进行旋转动画，可以在scaleEffect添加animation(nil)来实现。可以在这里做一些实验，如果把其它的一些动画效果结合在一起，会怎么样\n步骤6 学下一节之前，把本节中添加的animation(_:)修改器都去掉\n第二节 把视图的状态改态转化成动画效果 已经学会了给单个视图添加动画的方法，现在可以学习怎么在视图的状态发生改变时添加动画效果。当用户点击按钮时会切换showDetail状态的值，在视图变化过程中添加动画效果。\n步骤1 把showDetail.toggle()包裹在withAnimation函数调用块中。showDetail的改变影响了视图HikeDetail和详情切换按钮，在显示/隐藏详情的过程中都有了过滤动画效果。\n放慢动画速度，可以观察SwiftUI动画在被中断下是怎么运作的\n步骤2 给withAnimation传入一个时长4秒的基本动画参数.easeInOut(duration:4)，可以指定动画过程时长，给withAnimation传入的动画参数与.animation(_:)修改器可用参数一致。\n步骤3 在动画过程进行中点击按钮切换视图状态，查看对应的动画被中断时的效果\n步骤4 读下一节之前，把动画时长参数(.easeInOut(duration: 4))去掉，让动画不再缓慢进行。\n第三节 定制视图转场动画 默值情况下，视图离屏和入屏时的动画效果是渐隐/渐现， 这个默认的转场效果可以使用transition(_:)修改器进行定制。\n步骤1 给HikeView视图添加transition(_:)修改器，并定制转场参数为.slide，转场动画为滑入/滑出\n步骤2 可以把滑入/滑出这种转场动画封装起来，方便其它视图复用同样的转场效果\n步骤3 在moveAndFade转场效果的定义中使用move(edge:)，让滑入/滑出从屏幕的同一边进行\n步骤4 使用asymmetric(insertion:removal:)修改器来定制视图显示/消失时的转场动画效果\n第四节 组合复杂的动画效果 点击图表下面的三个按钮，会在三个不同的数据集间进行切换并展示。本节中会使用组合动画，让图表在不同数据集间切换时的转换动画流畅自然。\n步骤1 把showDetail的默认值改为true，并把HikeView的预览模式视图固定在画布上。这样可以在编辑其它文件时，依然看到动画效果的变化。\n步骤2 在HikeGraph.swift中定义了一个新的波动动画，并把它与滑入/滑出动画一起应用到图表视图上。\n步骤3 把动画切换为弹簧动画(spring)，并设置弹簧阻尼系数为0.5，动画过程中产生了逐渐回弹效果\n步骤4 加速弹簧动画的执行速度，缩短切换图表的时间\n步骤5 以当条形在图表中的位置为参数，添加延迟效果，图表中的每个条形会顺序动起来\n步骤6 观察一下自定义波动(rippling)效果是怎么作用在视图转场中的\n检查是否理解 问题1 怎样从一串动画效果调用中，去掉其中的一种动画效果。以下面的代码为例，怎样去掉旋转动画\n问题2 当你开发动画的过程上，为什么要把预览视图固定在画布上？\n为了固定动画过程中的当前帧 为了在多个设备配置开发中预览动画效果 为了在切换到其它不同文件时，固定显示当前视图的预览 问题3 在视图状态改变时，如何快速测试一个动画在被中断时的表现\n在包含animation(_:)修改器的代码行上打一个断点，然后\u0008单步按动画帧进行测试 调整动画的持续时长，让动画在足够长的时间内完成，这样就可以调整动画的细节 重复的调用sleep(100)来减慢动画的执行 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/swiftui_essentials/building_lists_and_navigation/",
	"title": "创建列表和导航",
	"tags": [],
	"description": "",
	"content": "地标详情页视图已经创建完成，我们需要提供一种方式让用户可以查看完整的地标列表，并且可以查看每一个地标的详情\n下面会创建一个可以展示任何地标信息的视图，并动态生成一个可滚动列表，用户可以点击列表项去查看地标的详细\u0008信息。优化视图显示时，可以使用Xcode画布来渲染多个不同设备大小下的预览视图。\n下载下面的工程文件，并跟着教程一步步学习构建列表和视图间导航\n项目文件 BuildingListsAndNavigation.zip (6 MB) 第一节 了解样本数据 前面的教程中，自\u0008定义视图所展示的信息都直接被写死在代码中，这篇教程中会学习给自定义视图传入样本数据进行展示\n步骤1 打开项目导航器，选择Models-\u0026gt;Landmark.swift文件，这个文件中声明了需要在应用中展示一个地标所需要信息的结构化名称，并通过导入landmarkData.json文件中的数据，生成一个地标信息数组。\n步骤2 在项目导航器中选择Resources-\u0026gt;landmarkData.json，在后面的教程中我们都会使用这个样本数据文件\n步骤3 注意，之前的ContentView视图，已经被改名为LandmarkDetail了，在本教程和后面的教程中，还会创建一些其它的视图\n第二节 创建行视图 本教程中创建的第一个视图就是用来显示每个地标的行视图，行视图把地标的相关信息存储在一个属性中，一行就可以代表一个地标，稍后就会把这些行组合成为一个列表。\n步骤1 创建一个名为LandmarkRow.swift的\u0008SwiftUI视图\n步骤2 如果预览视图没有出现，可以选择菜单编辑器-\u0026gt;画布，打开画布，并点击Resume进行预览，或者使用Command+Option+Enter快捷键调出画面，再使用Command+Option+P快捷键开始预览模式\n步骤3 添加landmark属性做为LandmarkRow视图的一个存储属性。当添加landmark属性后，预览视图可能会停止工作，因为LandmarkRow视图初始化时需要有一个landmark实例。要想修复预览视图，需要修改Preview Provider\n步骤4 在LandmarkRow_Previews的静态属性previews中给LandmarkRow初始化器中传入landmark参数，这个参数使用landmarkData数组的第一个元素。预览视图当前显示Hello, World\n步骤5 在一个HStack中嵌入一个Text\n步骤6 修改这个Text，让它使用landmark属性的name字段\n步骤7 在Text视图前面添加一个图片视图，在Text视图后面添加Spacer视图\n第三节 自定义行预览 Xcode的画布会自动识别当前代码编辑器中遵循PreviewProvider协议的类型，并将它们渲染并展示在画面上。一个视图预览提供者(preview provider)返回一个或多个视图，这些视图可以配置不同的大小和设备型号。\n可以定制从preview provider中返回的视图被渲染在何种场景下。\n步骤1 在LandmarkRow_Previews中，把landmark参数更新为landmarkData数组的第二个元素，预览视图会立即刷新反映第二个元素的渲染情况\n步骤2 使用previewLayout(_:)修改器设置一个行视图在列表中显示的尺寸大小。可以使用Group的方式，返回多个不同场景下的预览视图\n步骤3 把预览的行视图包裹在Group中，把之前的第一个行视图也加进去。Group是一个容器，它可以把视图内容组织起来，Xcode会把Group内的每个子视图当作画布内一个单独的预览视图处理\n步骤4 为了简化代码，可以把previewLayout(_:)这个修改器应用到外层的Group上，Group的每一个子视图会继承自己所处环境的配置。对preivew provider的修改只会影响预览画布的表现，对实际的应用不会产生影响。\n第四节 创建地标列表 使用SwiftUI列表类型可以展示平台相关的列表视图。列表的元素可以是静态的，类似于栈内部的子视图，也可以是动态生成的视图，也可以混合动态和静态的视图。\n步骤1 创建SwiftUI视图，命名为LandmarkList.swift\n步骤2 用List替换默认创建的Text，并将前两个LandmarkRow实例做为列表的子元素，预览视图中会以列表的形式展示出两个地标\n第五节 创建动态列表 \u0008除了单独列出列表中的每个元素外，列表还可以从一个集合中动态的生成。\n创建列表时可以传入一个集合\u0008\u0008数据和一个闭包，闭包会针对每一个数据元素返回一个视图，这个视图就是列表的行视图。\n步骤1 从列表中移除两个静态指定的行视图，给列表初始化器传入landmarkData数据，列表要配合可辨别的数据类型使用。想让数据变成可辨别的数据类型有两种方法:\n传入一个keypath指定数据中哪一个字段用来唯一标识这个数据元素。\n让数据遵循Identifiable协议\n步骤2 在闭包中返回一个LandmarkRow视图，List初始化器中指定数据集合landmarkData和唯一标识符keypath:\\.id，这样列表就会动态生成，如下图所示\n步骤3 切换到文件Landmark.swfit，声明Landmark类型遵循Identifiable协议，因为Landmark类型已经定义了id属性，正好满足Identifiable协议，所以不需要添加其它代码\n步骤4 现在切换回文件LandmarkList.swift，移除keypath\\.id，因为landmarkData数据集合的元素已经遵循了Identifiable协议，所以在列表初始化器中可以直接使用，不需要手动标明数据的唯一标识符了\n第六节 设置从列表页到详情页的页面导航 地标列表可以正常渲染展示，但是列表的元素点击后没有反应，跳转不到地标详情页。现在就要给列表添加导航能力，把列表视图嵌套到NavigationView视图中，然后把列表的每一个行视图嵌套进NavigationLink视图中，就可以建立起从地标列表视图到地标详情页的跳转。\n步骤1 把动态生成的列表视图嵌套进一个NavigationView视图中\n步骤2 调用navigationBarTitle(_:)修改器设置地标列表显示时的导航条标题\n步骤3 在列表的闭包中，将每一个行元素包裹在NavigationLink中返回，并指定LandmarkDetail视图为目标视图\n步骤4 切换到实时预览模式下可以直接点击地标列表的任意一行，现在就可以跳转到地标详情页了。\n第七节 子视图传入数据 LandmarkDetail视图目前还是使用写死的数据进行展示，与LandmarkRow视图一样，LandmarkDetail视图及它内部的子视图也需要传入landmark数据，并使用它来进行实际的展示\n从LandmarkDetail的子视图(CircleImage、MapView)开始，需要把它们都改造成为使用传入的数据进行展示，而不是在布局代码中写死数据展示\n步骤1 在CircleImage.swift文件中，添加一个存储属性，命名为image。这是一种在构建SwiftUI视图中很常用的模式，常常会包裹或封装一些属性修改器。\n步骤2 更新CirleImage的预览结构体，并传入Turtle Rock这个图片进行预览\n步骤3 在MapView.swift中添加一个coordinate属性，并使用这个属性来替换写死的\u0008经纬度坐标\n步骤4 更新MapView的预览结构体，并传入每一个地标的经纬度数据\n步骤5 在LandmarkDetail.swift中添加landmark属性。\n步骤6 更新LandmarkDetail预览结构体，并传入第一个地标的数据\n步骤7 把对应子视图的数据传入\n步骤8 最后调用navigationBarTitle(_:displayMode:)修改器为地标详情页展示时在导航条上设置一个标题\n步骤9 在SceneDelegate.swift中把应用的根视图替换为LandmarkList。应用在模拟器中独立启动时使用SceneDelegate的根视图做为第一个展示的视图\n步骤10 在LandmarkList.swift中，传入当前行的地标数据到地标详情页LandmarkDetail\n步骤11 切换到实时预览模式下去查看从地标列表页对应的行跳转到对应地标详情页是否正常\n第八节 动态生成预览视图 接下来要在不同尺寸设备上展示不同的预览视图，默认情况下，预览视图会选择当前Scheme选中的设备尺寸进行渲染，可以使用previewDevice(_:)修改器来改变预览视图的设备\n步骤1 改变当前预览列表，让它渲染在iPhone SE设备上。可以使用Xcode Scheme菜单上的设备名称来指定渲染设备。\n步骤2 在列表的预览视图中，还可以把LandmarkList嵌套进入ForEach实例中，使用设备数组名作为数据。ForEach运算作用在集合类型的数据上，就和列表使用集合类型数据一样，可以在子视图使用的任何场景下使用ForEach，例如：stack、list、group等。当元素数据是简单值类型时(例如字符串类型)，可以使用\\.self作为keypath去标识\n步骤3 使用previewDisplayName(_:)修改器可以给预览视图添加设备标签\n步骤4 可以在画布上多设置几个设备进行预览，比较不同设备下视图的展示情况\n检查是否理解 问题1 除了List外，下面哪种类型可以从集合数据中展示动态列表视图\nGroup ForEach UITableView 问题2 可以从遵循了Identifiable协议的集合数据创建列表视图。但如果集合数据不遵循Identifiable协议，还有什么办法可以创建列表视图？\n在集合数据上调用map(_:)方法 在集合数据上调用sorted(by:)方法 给List(_:id:)类型传入集合数据的同时，使用keypath指定一个唯一标识符字段 问题3 使用什么类型才能让列表的行实现点击跳转到其它视图页面？\nNavigationLink UITableViewDelegate NavigationView 问题4 下面哪种方式不是用来设置预览设备的？\n改变活动scheme中选中的模拟器 在画面设置中设置一个不同的预览设备 使用previewDevice(_:)指定一个或多个预览设备 连接开发机并点击设备预览按钮 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/",
	"title": "SwiftUI",
	"tags": [],
	"description": "",
	"content": "\nSwiftUI 借助 SwiftUI，您可以利用 Swift 的强大功能打造适合各个 Apple 平台的精美 app，而无需编写大量代码。SwiftUI 让您只需使用一套工具和 API，就能在任何 Apple 设备上为所有用户带来更加出色的体验。\nSwiftUI 新功能 先进的 app 体验和工具：您可以利用新功能增强您的 app，例如改进的列表视图、更好的搜索体验，以及对控制专注模式的支持。此外，还可以利用新的画布 API 这个 drawRect 的现代 GPU 加速替代方案，提高对底层绘图语言的控制。\n辅助功能改进：利用新的 Rotor API，以简单列表形式在屏幕上显示最相关的项目，从而加快互动速度。当前的辅助功能焦点状态 (例如旁白光标) 现在可以朗读出来，甚至可以通过编程方式进行更改。而借助新的辅助功能表示 API，您的自定控件即可轻松继承现有标准 SwiftUI 控件的完整辅助功能支持。\nmacOS 上的 SwiftUI 改进：新的性能与 API 可用性改进，包括多列表格支持，让您的 macOS app 变得更加出色。\n全天候视网膜显示屏支持：在 Apple Watch Series 5 及更新机型上，全天候视网膜显示屏让 watchOS app 即使在表盘变暗后，也能始终显示，重要信息一目了然。\n适用于 iPadOS 的小组件：现在，小组件可以放在主屏幕中的任意位置上，而且尺寸进一步增大，带来全新的超大小组件。\n声明式语法 SwiftUI 采用声明式语法，您只需声明用户界面应具备的功能便可。例如，您可以写明您需要一个由文本栏组成的项目列表，然后描述各个栏位的对齐方式、字体和颜色。您的代码比以往更加简单直观和易于理解，可以节省您的时间和维护工作。\nimport SwiftUI struct Content: View { @State var model = Themes.listModel var body: some View { List(model.items, action: model.selectItem) { item in Image(item.image) VStack(alignment: .leading) { Text(item.title) Text(item.subtitle).color(.gray) } } } } 这种声明式风格甚至适用于动画等复杂的概念。只需几行代码，就能轻松地向几乎任何控件添加动画并选择一系列即时可用的特效。在运行时，系统会处理所有必要的步骤和中断因素，来保证您的代码流畅运行、保持稳定。实现动画效果是如此简单，您还能探索新的方式让 app 更生动出彩。\n设计工具 Xcode 包含直观的设计工具，只需拖放操作就能使用 SwiftUI 轻松构建界面。当您在设计画布中操作时，您的每一项编辑都会与相邻编辑器中的代码保持完全同步。在您键入时代码会立即以预览形式显示，您对预览进行的任何更改会立即反映在您的代码中。Xcode 会即时重新编译您的更改，并将它们插入到 app 的运行版本中，方便您随时查看和编辑。\n拖放操作：只需在画布上拖放控件，就能调整组件在用户界面中的位置。点按打开检查器，即可选择字体、颜色、对齐方式和其他设计选项，并可通过光标轻松重新排列控件。多数这些可视化编辑器也可在代码编辑器中使用，因此您可以使用检查器来探索各个控件的新修饰符，即使您偏好手动编写界面组件代码也没问题。您还可以将控件从资源库拖放到设计画布上，或者直接拖放到代码中。\n动态替换：Swift 编译器和运行时已全面嵌入到 Xcode 中，您可以随时构建和运行您的 app。您看到的设计画布不仅看起来像是用户界面——它确实就是您实时运行的 app。此外，借助 Swift 中新推出的“动态替换”功能，Xcode 可以直接在实时运行的 app 中替换编辑后的代码。\n预览：您现在可以为任何 SwiftUI 视图创建一个或多个预览来获取样本数据。用户能看见的任何内容 (例如大字体、本地化或深色模式)，你几乎都能配置。预览也可以显示您的 UI 在任何设备和方向上的呈现效果。\n所有苹果设备原生支持SwiftUI SwiftUI是在苹果设备上创建用户界面的一种现代方法。可以更快的创建漂亮且充满活力的应用。\n只需要描述一次布局 声明式描述任何状态下的视图内容和布局。SwiftUI知道视图何时发生状态改变，并及时刷新对应状态下的视图内容。\n构建可复用组件 把多个目标单一的小视图组合成功能复杂的大视图进而组合成复杂的用户界面。同时自定义的视图还可以在不同的\u0008苹果平台设备应用开发中复用。\n简化动画效果实现 创建流畅的动画效果仅仅需要添加一个方法调用就可以完成。SwiftUI负责在必要时进行动画效果的内部计算和转场处理。\nXcode中实时预览 不需要实际运行应用就可以完成设计、构建和测试工作。使用交互式的预览功能来测试你开发的控件和页面布局。\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftpm/",
	"title": "SwiftPM",
	"tags": [],
	"description": "",
	"content": "SwiftPM Swift Package Manager简称SwiftPM或SPM，是用来管理Swift代码分发的工具，它与Swift构建系统集成在一起，可以自动处理代码的下载、编译和依赖链接。Swift 3.0及之后的版本中默认包含Swift Package Manager。\nSwift通过模块来组织代码，每一个模块都有一个对应的命名空间，模块中包含的代码会指定哪些部分可以被外部访问，哪些代码只能在模块内部使用。对于一个程序，可能所有的代码都写在一个模块中，也可能这个程序依赖了其它人写的模块。除了系统提供的模块可以被程序依赖以外，大部分情况下，我们写程序所依赖的其它模块都需要被先下载到本地，然后按指定顺序进行编译。\n假设为了解决一个特定的问题我们写了一个模块，如果其它场景或其它人也要解决同样的问题，就可以把这个已经写好的模块直接拿过来使用，不需要重新再写一遍，这就是使用模块的好处。模块可以被复用，来提高生产效率。\n在Swift Package Manager中，有几个概念需要先明确一下：\n包(Package): 一个包具体由Swift源码文件、清单文件(manifest)及资源文件(图片、视频、音频、文本等)组成。清单文件命名为Package.swift，使用PackageDescription模块定义了这个包的名称及包中包含的具体内容。从概念上来看，一个包中可能包含一个或多个编译目标(Target), 每一个编译目标会依赖一些其它的模块，一个编译目标经过编译器处理后会生成一个产物(Product)。 产物(Product): 一个编译目标(Target)经过编译器处理后生成的产物可以分为两类：库(library)和可执行文件(executable)。库(library)中可以包含多个模块，可执行文件(executable)可以被操作系统调起运行。 依赖(Dependency): 一个编译目标(Target)可能需要依赖其它模块才能被编译器成功编译生成产物，而依赖的模块可能存在于其它的包中。我们描述依赖的时候通常会使用一个URL及对应的版本号来指定，Swift Package Manage的作用就是自动的处理一个项目所依赖的所有包的下载工作并调用Swift工具链进行编译。一个包内部还会依赖其它包，这是一个递归的过程，可以用一棵依赖树来表示，Swift Package Manager就是解析这棵依赖树，下载所有的包并执行编译任务生成对应产物。 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/framework_integration/creating_a_macos_app/",
	"title": "创建macOS应用",
	"tags": [],
	"description": "",
	"content": "创建了watchOS平台的Landmarks应用后，下一步就是把Landmarks带到MacOS平台上。运用之前学到的所有知识，完成在iOS、watchOS及macOS的全平台应用。\n在项目工程中添加macOS编译目标，复用在iOS应用中的代码和资源，使用SwiftUI创建macOS平台上的列表和详情视图。\n按照步骤来编译工程，或者下载工程查看完成后的代码。\n项目文件 CreatingAmacOSApp.zip (10 MB) 第一节 项目中添加macOS编译目标 项目中添加macOS编译目标，Xcode会自动添加一个文件组与一些初始文件，还会生成一个编译运行方案。\n步骤1 选择File-\u0026gt;New-\u0026gt;Target，模板选择页面出现后，选择macOS选项卡，选中App模板并点击Next。这个模板会添加一个新的macOS编译目标到项目里。\n步骤2 在信息表中，输入MacLandmarks作为项目的名称，设置编程语言为Swift，界面构建方法为SwiftUI，然后点击Finish。\n步骤3 设置运行方案为MacLandmarks -\u0026gt; My Mac。这样就可以编译并运行macOS应用。\n这个应用的运行依赖一些特性，这些特性在早期的macOS上是不支持的，所以可能需要改变部署目标。\n步骤4 在项目导航器中，选择顶部的Xcode项目，在可用编译运行目标栏中，选择部署目标为10.15。\n步骤5 在MacLandmarks文件夹中，选择ContentView.swift文件，打开预览画布，点击恢复(Resume)，查看预览。SwiftUI会提供main视图和它的预览视图提供者，就像iOS应用，可以预览应用的主窗口。\n第二节 共享数据和资源 下一步，复用来自iOS应用的模型和资源文件到macOS应用中。\n步骤1 在项目导航器中，打开Landmarks文件夹并选中所有Models和Resources文件夹。landmarkData.json文件包含在教程的启动项目，里面包含了一个新的description字段，这是之前的教程中所没有的内容。\n步骤2 在文件检查器中，为选中的文件设置目标成员关系为MacLandmarks项目。应用编译时需要访问这些共享资源。要使用新的description字段，需要在Landmark结构体中添加一个对应的字段。\n步骤3 打开Landmark.swift文件，添加一个description属性。因为载入的数据遵循Codable协议，只需要确保属性名称和json文件中对应的字段名称一致就可以导入新增的字段数据了。\n第三节 创建行视图 对于使用SwiftUI来构建视图，一般是自底向上的方式，先创建小视图，然后用小视图组合成更大的视图。下面将创建一个列表的行视图。这个行视图包含地标的名称、地理位置、图片以及一个可选的标记，表标这个地标是否被收藏。\n步骤1 在MacLandmarks文件夹下添加一个新的SwiftUI视图，命名为LandmarkRow.swift。iOS应用下也有一个与之同名的文件，重名文件可以通过设置文件的目标成员为适合的App来解决重名的问题。\n步骤2 添加一个landmark属性到LandmarkRow结构体中，并更新预览视图，让新创建的视图可以在预览视图中展示出来。\n步骤3 用VStack包裹的地标图片视图替换占位文本Text视图。\n步骤4 添加一个包裹在VStack中的描述地标的文本视图。\n步骤5 添加一个收藏指示视图，把它和其它现有的内容用一个Spacer分割开。Spacer会把已有的视图推向左边，但是收藏指示视图要放在右边，目前是不可见状态，因为此时还没有图片资源与之对应。\n步骤6 从Resources文件夹下拖动star-filled.pdf和star-empty.pdf文件到macOS应用的Assets.xcassets文件内。\n步骤7 给行视图添加内边距，现在就能够把黄色的收藏标记显示出来了。行视图的内边距可以提高可读性，当把多个行视图集合到列表视图内时，这一点就能很明显的看出来了。\n第四节 把行视图组合进列表视图中 使用上一节创建的行视图，创建一个列表视图，用来展示用户了解的所有地标。当showFavoritesOnly属性为真时，列表中只展示那些被用户收藏的地标。\n步骤1 添加一个名为LandmarkList.swift的新的SwiftUI视图\n步骤2 添加userData属性作为环境注入对象，并更新预览视图。这样就可以让视图访问全局用户地标数据。\n步骤3 创建一个列表，行使用使用landmarkRow定义的类型。\n步骤4 让列表的行可以被用户选中，需要给列表提供一个绑定可选地标成员的关系，并用地标数据自己来标识行。之后会使用这个被选中的地标来展示地标详情页。\n步骤5 根据showFavoritesOnly的状态值以及地标数据是否被用户标记为收藏来决定列表中展示的行的内容。\n第五节 创建过滤器来管理列表的展示内容 因为用户可以标记地标为收藏状态，所以需要提供方式让用户只看到自己收藏过的地标。现在要创建一个过滤器视图，使用Toggle控件给用户提供一个勾选设置，让用户选择是否过滤列表中的非收藏地标，只展示收藏过的地标。\n为了让用户可以快速筛选出自己喜欢的地标，这里会添加一下选择器弹出按钮，让用户可以根据地标的不同类别，选择过滤展示自己收藏的地标数据。\n步骤1 添加一个名为Filter.swift的SwiftUI视图。\n步骤2 添加userData属性作为环境注入对象，并更新预览视图。\n步骤3 用Toggle控件来展示布尔值showFavoritesOnly属性，并给它一个恰当的标签文本。\n当用户选择勾选框时，列表视图也会跟着一起刷新展示，因为它们都绑定了同一上环境注入对象中的值showFavoritesOnly。除此之外，还可以使用地标的类别来定义额外的过滤条件。\n步骤4 创建FilterType类型，用来存放地标的类别以及类别对应的名称。确保FilterType遵循Hashable协议，这样FilterType就可以被用在选择器。FilterType中的名称属性可以展示在选择器中，让用户选择过滤哪一种类别的地标。\n步骤5 定义一个all类型用来表示不使用任何地标类别过滤。这个额外的过滤类别要求FilterType有一个特殊的初始构建器，用来处理类别为空的初始化场景。\n遵循CaseIterable和Identifiable协议，让FilterType可以做为ForEach的初始化入参，之后就可以使用这个FilterType类型了。\n步骤6 遵循CaseIterable协议，给列表提供所有可能的类别。\n步骤7 遵循Identifiable协议并定义一个id属性。\n步骤8 在Filter.swift中，给Filter视图添加一个选择器，选择器使用一个FilterType的绑定用来记录用户选择，FilterType的名称用来表示用户在选择器菜单中的选项。使用FilterType的绑定关系可以让父视图观察到用户的选择。\n步骤9 返回到列表视图，添加FilterType绑定关系。对于过滤器视图来说，这允许它和父视图共享变量filter。\n步骤10 更新列表行的创建逻辑，让它包含类别过滤功能。查找那些与用户选中的过滤类别相匹配的地标类别，或者任何用户选择的特色类别地标。\n第六节 组合列表视图与过滤器视图 创建一个组列过滤器和列表的视图。为过滤器提供新的状态信息，同时绑定地标选择到主视图的父视图上。\n步骤1 项目中添加一个新的SwiftUI视图，命名为NavigationPrimary.swift。\n步骤2 声明一个FilterType状态。这个状态会被绑定到过滤器和列表视图中。\n步骤3 添加过滤器视图并绑定FilterType状态。现在预览是失败的，因为过滤器依赖环境中的用户数据，下一步会处理这块儿。\n步骤4 注入用户数据对角到环境中。导航主视图是不直接需要用户数据的，但它的子视图需要。为了可以进行预览，把用户数据作为环境对象注入到导航主视图中。\n步骤5 添加一个绑定到当前选中地标的关系。\n步骤6 添加地标列表视图，并把它绑定到选中的地标和过滤器状态上。预览视图中选中第二个选项，因为输入数据是landmarkData[1]作为用户选中的地标输入数据。\n步骤7 限制导航视图的宽度，防止用户让它变的太宽或太窄。\n第七节 复用CircleImage 有时只需要经过稍微修改，就可以跨平台复用一些视图。当构建macOS平台的地标详情页视图时，会复用iOS版地标应用中的CircleImage视图。为了适配macOS平台下的不同布局要求，会添加一个参数来控件阴影半径。\n步骤1 在项目导航栏中选中Landmarks -\u0026gt; Supporting Views并选择CircleImage.swift文件。\n步骤2 把CircleImage.swift文件添加到时MacLandmarks编译目标。\n步骤3 在CircleImage.swift文件中，修改结构体，使用新的阴影半径参数。通过给新参数提供默认值，可以确保iOS和watchOS平台的应用都能与原来保持一致，同时还能在macOS平台上使用。\n第八节 为macOS扩展MapView 类似于CircleImage，这里要在macOS上复用MapView。然而，MapView要做更大的改动，因为MapView使用的是MapKit依赖于UIKit框架。在macOS平台上使用MapKit需要依赖于AppKit框架，所以需要添加编译器指令，让编译过程在macOS目标上进行正确的依赖。\n步骤1 在项目导航器中，选择Landmarks -\u0026gt; Supporting Views，选中MapView.swift文件。\n步骤2 把MapView.swift文件添加到MacLandmarks编译目标上。此时Xcode会报错，因为MapView使用了UIViewRepresentable协议，这个协议在macOS SDK里是没有的。下面的步骤中，会使用NSViewRepresentable协议来扩展MapView，让它能在macOS平台上使用。\n步骤3 插入条件编译指令，用来指定特定平台行为。用条件编译的两个条件分支把协议UIViewRepresentable和NSViewRepresentable协议的遵循分开。\n步骤4 使用条件编译，把在iOS平台上要实现的协议UIViewRepresentable及协议方法makeUIView、updateUIView放在MapView的扩展实现中，这样就把MapKit的平台依赖性解耦了。\n步骤5 添加在macOS平台上的NSViewRepresentable协议遵循。与UIViewRepresentable协议一样，NSViewRepresentable协议的实现也可以使用主类中的方法。\n第九节 构建详情视图 详情视图展示用户选中的地标信息。创建一个类似iOS平台地标应用的地标详情视图，不同之处在于，macOS平台有不同的数据表示方法，这就需要针对macOS平台对详情视图作一些裁剪，复用一些之前调整过的视图。\n步骤1 项目中添加一个新的视图，命名为NavigationDetail.swift，并添加一个landmark属性。初始化详情视图时会使用landmark属性来指定详情页展示的地标信息。\n步骤2 在NavigationDetail.swift内部创建一个滚动视图，滚动视图中包含一个VStack，VStack中又包含一个HStack,HStack中展示关于地标的图片CircleImage及Text地标文本信息。通过设置VStack的最大最小宽度，确保展示的内容保持一定的宽度，以适合用户阅读。跨平台复用视图是非常方便的，定制一下CircleImage视图，以满足当前的布局要求。\n步骤3 把输入的图片变为可缩放，并设置图片按视图大小展示，这样可以让CircleImage视图的大小与Text块文本的大小看上去比较匹配。这种修改方法不需要调整CircleImage的内部实现。\n步骤4 调整阴影半径，以匹配更小的图片。这个修改依赖之前对CircleImage视图所作的参数化改造。\n用户使用按钮标记一个地标是否被收藏。为了让这个动作生效，需要访问用户数据中的对应变量。\n步骤5 添加用户数据对应的环境对象，并创建一个基于当前选中地标的存储属性landmarkIndex\n步骤6 添加一个按钮，水平方式对齐地标名称，使用星星图标，并在点击时可以切换用户对这个地标的收藏状态。当用户修改地标数据时，在用户数据中查找被修改的地标数据，并用最新的数据更新原来的数据，让数据保持最新状态。\n步骤7 在分割区载下再添加一个地标的信息，对应数据中新增的字段description。\n预览视图中标题块会被挤到左边，因为描述内容比较多，把水平方向的宽度撑满了。\n步骤8 在详情视图顶部插入地图，调整地图的偏移，让地图和其它内容有一定区域的重叠。地图占满视图全宽，因此会把详情文本挤到预览视图的底部看不到的位置，但它实际上是存在的。\n步骤9 导入MapKit并添加一个Open in Maps的按钮，当按钮被点击时，打开地图应用并定位到地标位置。\n步骤10 把Open in Maps按钮叠放在地图的右下角。\n第十节 把主视图和详情视图组合起来 已经构建了所有的视图元素，把主视图和详情视图组合起来，共同构成ContentView。\n步骤1 在MacLandmarks文件夹中，选择ContentView.swift文件。\n步骤2 为选中的地标设置对应的属性selectedLandmark，并用@State属性标识为状态属性。使用可选类型定义selectedLandmark，可以不用为它设置默认值。因此，无论是预览视图还是应用初始化时，都可以不需要用户选中地标进行渲染。\n步骤3 把用户数据作为环境对象注入。ContentView本身不会直接依赖用户数据，但它的子视图需要访问用户数据。对于预览视图来说，为了正常预览和编译成功，ContentView需要获取用户数据。\n步骤4 在AppDelegate.swift中，为ContentView注入环境对象，这样可以让它的子视图访问到用户数据，应用也可以编译成功。\n步骤5 在ContentView中添加NavigationView作为顶级视图，并设置一个最小尺寸。\n步骤6 添加主视图，展示选中的地标。当用户选中地标列表中的某个地标时，被选中的地标数据就会被赋值到selectedLandmark属性上。\n步骤7 添加详情视图，详情视图不接收可选地标数据， 因些传入详情视图的地标数据需要确保不为空。用户选中地标前，地标详情视图不会渲染，这就是为会预览视图没有任何改变，还是和之前一样。\n步骤8 构建并运行应用。尝试改变过滤器的设置，或者点击详情页中的收藏按钮，观察视图内容的变化。\n检查是否理解 问题1 在macOS平台上，怎么构建一个由可移动分割条分割的主副视图界面？\n问题2 下面哪一个协议是Picker控件所使用数据类型必须遵循的？\nIdentifiable Hashable Equatable 问题3 下面哪一个示例正确的展示了将selectedLandmark属性绑定到列表中被选中的地标数据？\n问题4 在MacLandmarks应用的完成版中，为什么主视图要维持一个对selectedLandmark的绑定关系，但详情视图只是取selectedLandmark属性的值？\n因为详情页的入参不能为空，所以不能传入一个绑定关系 主视图可以根据用户的输入，改变selectedLandmark属性的值，但详情视图只是读取selectedLandmark属性的值来进行展示 只可以在一个子视图中绑定一个值，为了避免多个视图更新时发生冲突 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/swiftui_essentials/handling_user_input/",
	"title": "处理用户输入",
	"tags": [],
	"description": "",
	"content": "在Landmark应用中，标记喜爱的地方，过滤地标列表，只显示喜欢的地标。要增加这些特性，首先要在列表上添加一个开关，用来过滤用户喜欢的地标。在地标上添加一个星标按钮，用户可以点击它来标记这个地标为自己喜欢的。\n下载工程文件并且跟着下面的教程实践\n项目文件 HandlingUserInput.zip (6 MB) 第一节 标记用户最喜欢的地标 给地标列表的每一行添加一个星标用来表示用户是否标记该地标为自己喜欢的\n步骤1 打开工程项目，在项目导航下选择LandmarkRow.swift文件\n步骤2 在空白占位后面添加一个if表达式，if表达\u0008式判断是否当前地标是用户喜欢的，如果用户标记当前地标为喜欢就显示星标。可以在SwitUI的代码\u0008块中使用if语句来条件包含视图\n步骤3 由于系统图片是\u0008矢量类型的，可以使用foregroundColor(_:)来改变它的颜色。当地标landmark的isFavorite属性为真时，星标显示，稍后会\u0008讲怎么修改属性值。\n第二节 过滤列表 可以定制地标列表，让它只显示用户喜欢的地标，或者显示所有的地标。要实现这个功能，需要给LandmarkList视图类型添加一些状态变量。\n状态(State)是一个值或者一个值的集合，会\u0008随着时间而改变，同时会影响视图的内容、行为或布局。在属性前面加上@State修饰词就是给视图添加了一个状态值\n步骤1 选择LandmarkList.swift文件，并给LandmarkList添加一个名为showFavoritesOnly的状态，初始值设置为false\n步骤2 点击Resume按钮或快捷键Command+Option+P刷新画布。当对视图进行添加或修改属性等结构性改变时，需要手动刷新画布\n步骤3 代码中通过检查showFavoritesOnly属性和每一个地标的isFavorite属性值来过滤地标列表所展示的内容\n第三节 添加控件来切换状态 为了让用户控制地标列表的过滤器，需要添加一个可以修改showFavoritesOnly值的控件，传递一个绑定关系给toggle控件可以实现\n一个绑定关系(binding)是对可变状态的引用。当用户点击toggle控件，从开到关或从关到开，toggle控件会通过绑定关系对应的更新视图的状态\n步骤1 创建一个嵌套的ForEach组来把地标数据转换成地标行视图。在一个列表中组合静态和动态视图，或者组合两个甚至多个不同的动态视图组，使用ForEach类型动态生成而不是给列表传入数据集合生成列表视图\n步骤2 添加一个Toggle视图作为列表的每一个子视图，传入一个showFavoritesOnly的绑定关系。使用$前缀来获得一个状态变量或属性的绑定关系\n步骤3 实时预览模式下，点击Toggle控件来验证过滤器的功能\n第四节 使用可观察对象来存储数据 要实现用户标记哪个地标为自己喜爱的地标这个功能，需要使用可观察对象(observalble object)存放地标数据\n可观察对象是一种可以绑定到具体SwifUI视图环境中的数据对象。SwiftUI可以察觉它影响视图展示的任何变化，并在这种变化发生后及时更新对应视图的展示内容\n步骤1 创建一个名为UserData.swift的文件\n步骤2 声明一个遵循ObservableObject协议的新数据模型，ObservableObject协议来自\u0008\u0008响应式框架Combine。SwiftUI可以订阅可观察对象，并在数据发生改变时更新视图的显示内容\n步骤3 添加存储属性showFavoritesOnly和landmarks，并赋予初始值。可观察对象需要对外公布内部数据的任何改动，因此订阅此可观察对象的订阅者就可以获得对应的数据改动信息\n步骤4 给新建的数据模型的每一个属性添加@Published属性修饰词\n第五节 视图中适配数据模型对象 已经创建了UserData可观察对象，现在要改造视图，让它使用这个新的数据模型来存储视图内容数据\n步骤1 在LandmarkList.swift文件中，使用@EnvironmentObject修饰的userData属性来替换原来的showFavoritesOnly状态属性，并对预览视图调用environmentObject(_:)修改器。只要environmentObject(_:)修改器应用在视图的父视图上，userData就能够自动获取它的值。\n步骤2 替换原来使用showFavoritesOnly状态属性的地方，改为使用userData中的对应属性。与@State修饰的属性一样，也可以使用$前缀访问userData对象的成员绑定引用\n步骤3 创建ForEach实例时使用userData.landmarks做为数据源\n步骤4 在SceneDelegate.swift中，对LandmarkList视图调用environmentObject修改器，这样可以把UserData的数据对象绑定到LandmarkList视图的环境变量中，子视图可以获得父视图环境中的变量。此时如果在模拟器或者真机上运行应用，也可以正常展示视图内容\n步骤5 更新LandmarkDetail视图，让它从父视图的环境变量中取要展示的数据。之后在更新地标的用户喜爱状态时，会用到landmarkIndex这个变量\n步骤6 切换到LandmarkList.swift文件，并打开实时预览视图去验证所添加的功能是否正常工作\n第六节 为每一个地标创建一个喜爱按钮 Landmark这个应用可以在喜欢和不喜欢的地标列表间进行切换了，但喜欢的地标列表还是硬编码形成的，为了让用户可以自己标记哪个地标是自己喜欢的，需要在地标详情页添加一个标记喜欢的按钮\n步骤1 在LandmarkDetail.swift的HStack中添加地标名称的Text\n步骤2 在地标名称的Text控件旁边添加一个新的按钮控件。使用if-else条件语句设置不同的图片显示状态表示这个地标是否被用户标记为喜欢。在Button的动作闭包中，使用了landmarkIndex去修改userData中对应地标的数据。\n步骤3 切换到landmarkList.swift，并开启实时预览模式。当从列表页导航进入详情页后，点击喜欢按钮，喜欢的状态会在返回列表页后与列表中对应的地标喜欢状态保持一致，因为列表页和详情页的地标数据使用的是同一份，所以可以在不同页面间保持状态同步。\n检查是否理解 问题1 下列选项哪个可以把数据按视图层级关系传递下去？\n@EnvironmentObject属性 environmentObject(_:)修改器 问题2 绑定(binding)的作用是什么？\n绑定是值和改变值的方法 是一个视图连接在一起的方法，确保连续起来的视图接收同一份数据 是一个临时固化值的方式，目的是在其它视图状态变化时，保持值不改变 "
},
{
	"uri": "https://swift.jokerhub.cn/combine/",
	"title": "Combine",
	"tags": [],
	"description": "",
	"content": "Combine 运用各种事件处理算子处理异步事件\n系统版本要求\nOS 13.0+ macOS 10.15+ Mac Catalyst 13.0+ tvOS 13.0+ watchOS 6.0+ 概述 Combine框架提供声明式的Swift API来处理随时间变化的值。这些随时间变化的值可以代表异步事件流。\nCombine通过声明publisher(发布器)来传递随时间变化的值，供subscriber(订阅器)来接收处理。\nPublisher协议声明一个可以传递随时间变化的值的类型，并且定义了一些算子可以处理从上一个发布器接收的值，并将处理后的值传递给后面的接收器。\n在发布器链路的末端，接收器处理接收到的每一个值。需要接收器主动请求，发布器才会吐出对应的值对接收器，这样可以在接收器侧通过代码控制获取值的速率。\n"
},
{
	"uri": "https://swift.jokerhub.cn/tdd/tdd_cycle/",
	"title": "TDD 迭代循环",
	"tags": [],
	"description": "",
	"content": " 写任何业务代码前，先写一个会失败的测试用例 写最少的业务代码，让之前写的失败的测试用例通过测试 重构你的业务代码和测试用例代码 重复前面三个步骤，确何测试用例通正确通过测试 这个不断循环的开发流程被称为:Red - Green - Refactor循环\n在这个循环过程中，可以把编译失败也看做是一次测试失败来处理\n"
},
{
	"uri": "https://swift.jokerhub.cn/tdd/",
	"title": "TDD",
	"tags": [],
	"description": "",
	"content": "测试驱动开发 Test-Driven Development 把需求转换为测试用例，再把测试用例转换成生产环境代码\n要求熟悉Swift语言与iOS应用开发基本流程\n测试驱动开发是一种软件开发迭代方法，大体包含四个步骤：\n写失败的测试用例 让测试用例通过 修改代码 重复整体过程 测试驱动开发可以通过写好的测试用例，确保你的软件在现在和未来都可以按照预想的方式正常运行\n一个好的测试用例包含下面四个特点：\n条件不满足的情况下会发生失败 可以被不断的重复执行 运行耗时很短 容易维护 测试覆盖率越高并不一定意味着软件被测试的越好了。\n不需要对所有的逻辑都写测试\n通常对那些不能被自动化检测的代码逻辑写测试， 自动生成的代码逻辑则没有必要写测试，因为自动生成器应该保证它们自动生成的代码逻辑的正确性 对于可以触发编译警告和错误的代码逻辑也不需要写测试，因为编译器会发现它们 不要为依赖代码写测试，依赖代码的测试应该由依赖提供方来保证 在为了学习某个组件运行逻辑时，也可以写一些临时的测试，但是要记得用完后清理掉 对于测试驱动开发，通常有人会抱怨开发周期太长，耗时又费力。但是如果从长期来看，软件开发的时间成本，不仅仅是开发第一个版本所花费的时间，它应该还包括后期维护时迭代需求、代码重构、问题修复以及重复测试的时间。测试驱动开发从长期来看，是可以为软件开发工作节省整体成本的，同时它可以让问题尽早的暴露在开发阶段，避免造成线上问题\n什么情况下应该采用TDD开发模式 如果你的软件需要长期维护、不断的迭代新功能和发布新版本，并且会不断的集成新功能和一些复杂逻辑，测试驱动开发就适合被引入到软件项目中。如果只是临时项目，测试驱动开发就是看你自己的决定了。\n总体来说，测试驱动开发只是一种软件开发工具，具体情况还需要具体分析优缺点来决定是否采用\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/swiftui_essentials/",
	"title": "SwiftUI基础",
	"tags": [],
	"description": "",
	"content": "学习使用SwiftUI把简单的视图组合成复杂的页面、建立数据流以及页面间的导航，同时在Xcode中预览效果\n包含章节 创建和组合视图 创建列表和导航 处理用户输入 "
},
{
	"uri": "https://swift.jokerhub.cn/dp/",
	"title": "Design Pattern",
	"tags": [],
	"description": "",
	"content": "设计模式 如何成为一个真正的高级开发者 事实上，许多高级开发者仅仅只是拥有一个头衔，并不是真正具有高级开发者的实力。\n那么，应该如何识别一个真正的高级开发者呢？\n高级开发者应该具备哪些素质和能力？\n"
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/drawing_and_animation/",
	"title": "绘制和动画",
	"tags": [],
	"description": "",
	"content": "学习绘制形状和路径，并创建徽章和添加动画\n包含章节 绘制路径和形状 视图动画和转场 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/app_design_and_layout/",
	"title": "应用设计与布局",
	"tags": [],
	"description": "",
	"content": "深入了解使用SwiftUI创建的复杂的用户界面的结构和布局\n包含章节 组合复杂用户界面 玩转UI控件 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftui/framework_integration/",
	"title": "框架集成",
	"tags": [],
	"description": "",
	"content": "混合使用SwiftUI框架和平台相关的其它UI框架(视图和视图控制器)\n包含章节 与UIKit交互 创建watchOS应用 创建macOS应用 "
},
{
	"uri": "https://swift.jokerhub.cn/swiftpm/swiftpm_plugin/",
	"title": "Swift Package Plugin",
	"tags": [],
	"description": "",
	"content": "Xcode 11 引入了Swift Package, 它提供了一种将库作为源代码发布的好方法，Xcode 14将这种方法进行了扩展，让它可以使用插件来执行操作。例如构建过程中生成源码、自动完成发布任务。\n什么是包插件(Package Plugin) 包插件是一种可以对软件包或者Xcode项目执行操作的Swift脚本，包插件使用Xcode专门提供的API，以软件包(Swift Package)的形式实现。一个软件包可以只包含一个插件，也可以包含多个插件。一个插件可以由多个Swift源文件构成。\n一个软件包(Swift Package)中不仅可以包含库(.library)、产品(.product)、可执行文件(.executable)，也可以包含插件(package plugins)\n软件包中定义的插件可以只限制在当前软件包中使用，也可以作为产品，提供给其它依赖方使用。与正常软件包被依赖的方式不同的时，插件的运行时内容不会带入App，但它可以访问项目所在构建机器上的相关工具或者目录。\nXcode 14中支持了两种插件类型：Command Plugin和Build Tool Plugin\n命令插件可以执行类似代码格式化、更新git仓库贡献者列表或者一些预发布操作，有一些插件需要获取文件访问权限(例如代码格式化操作)，其它的插件可能不需要操作文件内容\n构建工具插件可以作用于每一个需要它们的编译Target，可以在项目构建过程中生成源码或者处理相关资源\n如果一个包插件在一个软件包中已经实现并允许被依赖，那么依赖包插件的方式和正常使用软件包的方式相关，只需要将插件所在的软件包添加到项目依赖中即可。\n要执行包插件，可以在Xcode中的包名上右键选择弹出的包插件菜单项，也可以用命令行的方式运行包插件。如果包插件定义了用户可输入的参数，在执行时也可以接受用户输入参数。\n包插件在Xcode中运行时，会弹窗提示用户需要针对哪些Target运行，如果插件运行涉及到获取文件访问权限，Xcode也会提示用户，并可以跳转到插件中实际申请文件访问权限的代码位置。\n包插件是如何工作的? 包插件是根据需要进行编译运行的Swift脚本，每一个包插件都在一个单独的进程中运行。包插件可以获取到运行所在软件包的相关信息、机器的命令行工具、操作文件系统、调用基础库能力去完成工作。\n包插件是在阻止访问网络的沙盒环境中运行的，默认可以直接读写指定的几个文件系统位置。命令插件需要访问其它文件系统位置，需要额外请求对应的权限。\n包插件也可以将执行结果发给Xcode，让Xcode展示一些提示信息、警告或者错误。\n包插件的实现依赖Xcode中PackagePlugin模块提供的API。下面是一个插件定义的简化示例：\nimport PackagePlugin @main struct MyPlugin: CommandPlugin { // 入口函数的定义，依赖于插件的具体类型 } 命令插件(Command Plugin) 命令插件扩展了开发工作流程，它直接作用于软件包，不在项目构建期间运行。并非所有的命令插件都需要文件系统权限，但如果命令插件确实需要申请文件系统权限，需要在包清单文件中指明相关权限申请项信息。有申请权限的命令插件，在运行之前，Xcode会提示用户是否授权命令插件需要的对应权限，只有用户允许对应的权限，插件才能运行。\n插件通常很小，依赖其它工具完成任务，依赖项可以是源码，也可以二进制文件，在插件运行之前，Xcode会对相关依赖工具的源码进行编译。\n一个命令插件的定义框架示例：\nimport PackagePlugin @main struct MyPlugin: CommandPlugin { // 入口函数的定义，依赖于插件的具体类型 func performCommand(context: PluginContext, arguments: [String]) throws { // 执行插件逻辑 } } 除了在Xcode中使用GUI的方式调用插件运行外，还可以使用命令行工具运行插件。Swift Package Manager 5.6时提供了和插件相关的子命令，swift package plugin --list可以用来查看所有插件。涉及到需要获取额外文件系统权限申请的命令插件时，使用命令行方式运行，也会有对应的权限提示，询问用户是否授与对应插件相应的权限。如果在命令行运行插件时想到默认直接允许权限申请时，可以使用--allow-writing-to-package-directory选项。命令行运行时，也可以给插件传入对应的参数。\n构建工具插件(Build Tool Plugin) 构建工具插件在调用时不会立即完成任务，它只是为构建系统提供对应时机的回调，以便在项目构建的对应时机执行预先定义好的行为。\n构建工具插件在阻止网络访问的沙盒中运行，它不能对包做任何修改。一个构建工具插件的定义框架发示例如下:\nimport PackagePlugin @main struct MyPlugin: BuildToolPlugin { // 入口函数的定义，依赖于插件的具体类型 func createBuildCommands(context: PluginContext, target: Target) throws -\u0026gt; [Command] { // 配置并返回构建命令 } } 构建工具插件可以定义两种类型的构建命令：\n预构建命令：构建开始之前执行的命令 普通构建命令：指定输入/输出路径，只用在输出路径缺失或者输入路径发生变化时执行 创建包插件(Swift Packag Plugins) 软件包插件是一种使用 PackagePlugin API 的类似于软件包清单的Swift代码，插件可以通过定义明确的扩展点扩展 Xcode或Swift软件包管理器的功能。\nSwift工具链版本需要在5.6版本及以上才支持包插件功能。Swift清单文件中需要指定工具链版本至少是5.6，清单文件中定义插件的示例：\n.plugin( name: \u0026#34;GenerateContributors\u0026#34;, capability:.command( intent: .custom( verb: \u0026#34;regenerate-contributors-list\u0026#34;, description: \u0026#34;Generates the CONSTRIBUTORS.txt file based on Git logs\u0026#34; ), permissions: [ .writeToPackageDirectory(reason: \u0026#34;Writes CONTRIBUTORS.txt to the source root.\u0026#34;) ] ) ) 如果在Xcode中右键包名时，菜单里没有出现插件项时，重启Xcode可以解决。\n在软件包根目录中创建Plugins/GenerateContributors/目录，并新建plugin.swift文件，\nimport Foundation import PackagePlugin @main struct GenerateContributors: CommandPlugin { func performCommand(context: PackagePlugin.PluginContext, arguments: [String]) async throws { let process = Process() process.executableURL = URL(fileURLWithPath: \u0026#34;/usr/bin/git\u0026#34;) process.arguments = [\u0026#34;log\u0026#34;, \u0026#34;--pretty=format:- %an \u0026lt;%ae\u0026gt;%n\u0026#34;] let outputPipe = Pipe() process.standardOutput = outputPipe try process.run() process.waitUntilExit() let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile() let output = String(decoding: outputData, as: UTF8.self) let contributors = Set(output.components(separatedBy: CharacterSet.newlines)).sorted().filter { !$0.isEmpty } try contributors.joined(separator: \u0026#34;\\n\u0026#34;).write(toFile: \u0026#34;CONTRIBUTORS.txt\u0026#34;, atomically: true, encoding: .utf8) } } 插件运行细节 插件运行在沙盒中，网络连接以及除插件本身运行目录之外的非临时位置都会被禁止。自定义命令可以选择性声明是否写入软件包根目录，如果要包装已有的第三方工具，必须考虑如何将其限制在沙盒模式中。例如：可以通过配置生成文件的写入位置来实现\n构建工具插件 构建工具插件的两种不同类型区分的要点是工具是否定义了输出集。如果有输出集，可以创建构建时命令，输出与输入对比如果过时，构建系统会自动重新运行。如果没有输出集，可以创建构建前命令，构建前命令会在每次构建开始时运行，应该避免在构建前命令中执行耗时操作。\n构建时命令 构建时命令与自定义命令的不同之处在于，除了描述可执行文件，还需要指定输入输出\n... .executableTarget(name: \u0026#34;AssetConstantsExec\u0026#34;), .plugin(name: \u0026#34;AssetConstants\u0026#34;, capability: .buildTool(), dependencies: [\u0026#34;AssetConstantsExec\u0026#34;]) Plugins/AssetConstants/plugin.swift文件示例如下：\nimport PackagePlugin struct AssetConstants: BuildToolPlugin { func createBuildCommands(context: PluginContext, target: Target) async throws -\u0026gt; [Command] { guard let target = target as? SourceModuleTarget else { return [] } return try target.sourceFiles(withSuffix: \u0026#34;xcassets\u0026#34;).map { asset in let base = asset.path.stem let input = asset.path let output = context.pluginWorkDirectory.appending([\u0026#34;\\(base).swift\u0026#34;]) return .buildCommand(displayName: \u0026#34;Generating constrants for \\(base)\u0026#34;, executable: try context.tool(named: \u0026#34;AssetConstantsExec\u0026#34;).path, arguments: [input.string, output.string], inputFiles: [input], outputFiles: [output] ) } } } 预编译命令 与构建时命令的区别之处在于，预编译命令返回的值是.prebuildCommand\nimport PackagePlugin struct AssetConstants: BuildToolPlugin { func createBuildCommands(context: PluginContext, target: Target) async throws -\u0026gt; [Command] { guard let target = target as? SourceModuleTarget else { return [] } let resourcesDirectoryPath = context.pluginWorkDirectory .appending(subpath: target.name) .appending(subpath: \u0026#34;Resources\u0026#34;) let localizationDirectoryPath = resourcesDirectoryPath .appending(subpath: \u0026#34;Base.lproj\u0026#34;) try FileManager.default.createDirectory(atPath: localizationDirectoryPath.string, withIntermediateDirectories: true) let swiftSourceFiles = target.sourceFiles(withSuffix: \u0026#34;.swift\u0026#34;) let inputFiles = swiftSourceFiles.map(\\.path) return [ .prebuildCommand( displayName: \u0026#34;Generating localized strings from source files\u0026#34;, executable: .init(\u0026#34;/usr/bin/xcrun\u0026#34;), arguments: [ \u0026#34;genstrings\u0026#34;, \u0026#34;-SwiftUI\u0026#34;, \u0026#34;-o\u0026#34;, localizationDirectoryPath ] + inputFiles, outputFilesDirectory: localizationDirectoryPath ) ] } } 相关参考资料 Swift 软件包插件简介 构建Swift软件包插件 "
},
{
	"uri": "https://swift.jokerhub.cn/dp/note/",
	"title": "高级开发者学习笔记",
	"tags": [],
	"description": "",
	"content": "单例和全局可变状态 Singleton: 完整的单例，一个类型只有一个实例 singleton: 不完整单例，一个类型有一个公用实例，但也可以根据需求创建其它实例 global mutable state: 全局可变状态会对单元测试造成阻碍，应该尽量避免 依赖反转(倒置) 注入方法 通过闭包：单个的闭包可以看作是只有一个接口声明的协议，它们可以相互转换 通过协议：是一组接口的包装 注入方式 初始化构造器注入 属性成员注入 方法注入 依赖图 依赖图是一种交流工具，设计工具\n实线空箭头: 表示类继承关系 实线实箭头: 表示成员强依赖关系 虚线空箭头: 表示协议遵循关系 虚线实箭头: 表示成员弱依赖关系 方框加类名表示类型 方框类名尖括号包裹表示协议类型，即接口。 类型组合 可以把不同的类型组合成一个新的类型\n开闭原则+依赖倒置 模块化设计 模块化设计后，一些和特定平台无关的模块，可以单独进行测试，平台解藕也可以实现。 例如：原来在iOS模拟器跑的模块测试可以转移到Mac设备上进行，从而提升效率\n模块化设计后，不同的模块开发工作可以合理的并行开发，节省时间成本，提高开发效率\n所有的架构都是好的，区别只在于需要解决问题时的具体选择。选择最合适的架构优雅的解决问题才是目的\n好的架构是由良好的沟通中产生的\n建立良好的需求开发流程\nBDD-\u0026gt;TDD-\u0026gt;UserCases-\u0026gt;Architecture-\u0026gt;ModularDesign\n沟通是关键，明确需求，细化实现，降低风险\n尽量少用单例模式，通常单例模式是反模式的，不利于维护，我们使用单例大部分场景，只是为了更方便的调用，仅此而已，但这不利于代码的模块化设计，因为会造成很多耦合点\n写单元测试 SUT(System Under Test) 测试方法命名：test_method_expectation 单元测试涉及的四个术语：\nStubbing Spying Mock dummy 善用Result类型，可以简化分支数量\n测试网络请求的方法 端到端：通过检查客户端-服务端之间真实的请求进行，由于依赖真实的网络请求，所以效率比较低，无法单独进行测试。 子类Mock：不适合对我们不清楚的类进行子类化 协议Mock：UR Loading System 请求拦截：URLProtocol/registerClass(AnyClass)/unregisterClass(AnyClass) "
},
{
	"uri": "https://swift.jokerhub.cn/",
	"title": "Learn Swift",
	"tags": [],
	"description": "",
	"content": "站点主要记录我学习Swift及相关知识的过程，做为一个iOS开发者自我提升过程中的各种积累和沉淀。\n"
},
{
	"uri": "https://swift.jokerhub.cn/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://swift.jokerhub.cn/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://swift.jokerhub.cn/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]